// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.13.
// **********************************************************************

#ifndef __ADMINREG_H_
#define __ADMINREG_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "NodeDescriptor.h"
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace tars
{
    enum tarsErrCode
    {
        EM_TARS_NODE_NOT_REGISTRY_ERR = 1001,
        EM_TARS_CALL_NODE_TIMEOUT_ERR = 1002,
        EM_TARS_LOAD_SERVICE_DESC_ERR = 1003,
        EM_TARS_SERVICE_STATE_ERR = 1004,
        EM_TARS_REQ_ALREADY_ERR = 1005,
        EM_TARS_INVALID_IP_ERR = 1006,
        EM_TARS_PARAMETER_ERR = 1007,
        EM_TARS_OTHER_ERR = 1008,
        EM_TARS_GET_PATCH_FILE_ERR = 1009,
        EM_TARS_PREPARE_ERR = 1010,
        EM_TARS_CAN_NOT_EXECUTE = 1011,
        EM_TARS_NODE_NO_CONNECTION = 1012,
        EM_TARS_UNKNOWN_ERR = -1,
        EM_TARS_SUCCESS = 0,
    };
    inline string etos(const tarsErrCode & e)
    {
        switch(e)
        {
            case EM_TARS_NODE_NOT_REGISTRY_ERR: return "EM_TARS_NODE_NOT_REGISTRY_ERR";
            case EM_TARS_CALL_NODE_TIMEOUT_ERR: return "EM_TARS_CALL_NODE_TIMEOUT_ERR";
            case EM_TARS_LOAD_SERVICE_DESC_ERR: return "EM_TARS_LOAD_SERVICE_DESC_ERR";
            case EM_TARS_SERVICE_STATE_ERR: return "EM_TARS_SERVICE_STATE_ERR";
            case EM_TARS_REQ_ALREADY_ERR: return "EM_TARS_REQ_ALREADY_ERR";
            case EM_TARS_INVALID_IP_ERR: return "EM_TARS_INVALID_IP_ERR";
            case EM_TARS_PARAMETER_ERR: return "EM_TARS_PARAMETER_ERR";
            case EM_TARS_OTHER_ERR: return "EM_TARS_OTHER_ERR";
            case EM_TARS_GET_PATCH_FILE_ERR: return "EM_TARS_GET_PATCH_FILE_ERR";
            case EM_TARS_PREPARE_ERR: return "EM_TARS_PREPARE_ERR";
            case EM_TARS_CAN_NOT_EXECUTE: return "EM_TARS_CAN_NOT_EXECUTE";
            case EM_TARS_NODE_NO_CONNECTION: return "EM_TARS_NODE_NO_CONNECTION";
            case EM_TARS_UNKNOWN_ERR: return "EM_TARS_UNKNOWN_ERR";
            case EM_TARS_SUCCESS: return "EM_TARS_SUCCESS";
            default: return "";
        }
    }
    inline int stoe(const string & s, tarsErrCode & e)
    {
        if(s == "EM_TARS_NODE_NOT_REGISTRY_ERR")  { e=EM_TARS_NODE_NOT_REGISTRY_ERR; return 0;}
        if(s == "EM_TARS_CALL_NODE_TIMEOUT_ERR")  { e=EM_TARS_CALL_NODE_TIMEOUT_ERR; return 0;}
        if(s == "EM_TARS_LOAD_SERVICE_DESC_ERR")  { e=EM_TARS_LOAD_SERVICE_DESC_ERR; return 0;}
        if(s == "EM_TARS_SERVICE_STATE_ERR")  { e=EM_TARS_SERVICE_STATE_ERR; return 0;}
        if(s == "EM_TARS_REQ_ALREADY_ERR")  { e=EM_TARS_REQ_ALREADY_ERR; return 0;}
        if(s == "EM_TARS_INVALID_IP_ERR")  { e=EM_TARS_INVALID_IP_ERR; return 0;}
        if(s == "EM_TARS_PARAMETER_ERR")  { e=EM_TARS_PARAMETER_ERR; return 0;}
        if(s == "EM_TARS_OTHER_ERR")  { e=EM_TARS_OTHER_ERR; return 0;}
        if(s == "EM_TARS_GET_PATCH_FILE_ERR")  { e=EM_TARS_GET_PATCH_FILE_ERR; return 0;}
        if(s == "EM_TARS_PREPARE_ERR")  { e=EM_TARS_PREPARE_ERR; return 0;}
        if(s == "EM_TARS_CAN_NOT_EXECUTE")  { e=EM_TARS_CAN_NOT_EXECUTE; return 0;}
        if(s == "EM_TARS_NODE_NO_CONNECTION")  { e=EM_TARS_NODE_NO_CONNECTION; return 0;}
        if(s == "EM_TARS_UNKNOWN_ERR")  { e=EM_TARS_UNKNOWN_ERR; return 0;}
        if(s == "EM_TARS_SUCCESS")  { e=EM_TARS_SUCCESS; return 0;}

        return -1;
    }

    enum EMTaskCommand
    {
        EM_CMD_START,
        EM_CMD_STOP,
        EM_CMD_PATCH,
        EM_CMD_UNINSTALL,
    };
    inline string etos(const EMTaskCommand & e)
    {
        switch(e)
        {
            case EM_CMD_START: return "EM_CMD_START";
            case EM_CMD_STOP: return "EM_CMD_STOP";
            case EM_CMD_PATCH: return "EM_CMD_PATCH";
            case EM_CMD_UNINSTALL: return "EM_CMD_UNINSTALL";
            default: return "";
        }
    }
    inline int stoe(const string & s, EMTaskCommand & e)
    {
        if(s == "EM_CMD_START")  { e=EM_CMD_START; return 0;}
        if(s == "EM_CMD_STOP")  { e=EM_CMD_STOP; return 0;}
        if(s == "EM_CMD_PATCH")  { e=EM_CMD_PATCH; return 0;}
        if(s == "EM_CMD_UNINSTALL")  { e=EM_CMD_UNINSTALL; return 0;}

        return -1;
    }

    enum EMTaskStatus
    {
        EM_T_NOT_START,
        EM_T_PREPARE,
        EM_T_RUNNING,
        EM_T_SUCCESS,
        EM_T_FAILED,
        EM_T_CANCEL,
        EM_T_PARIAL,
    };
    inline string etos(const EMTaskStatus & e)
    {
        switch(e)
        {
            case EM_T_NOT_START: return "EM_T_NOT_START";
            case EM_T_PREPARE: return "EM_T_PREPARE";
            case EM_T_RUNNING: return "EM_T_RUNNING";
            case EM_T_SUCCESS: return "EM_T_SUCCESS";
            case EM_T_FAILED: return "EM_T_FAILED";
            case EM_T_CANCEL: return "EM_T_CANCEL";
            case EM_T_PARIAL: return "EM_T_PARIAL";
            default: return "";
        }
    }
    inline int stoe(const string & s, EMTaskStatus & e)
    {
        if(s == "EM_T_NOT_START")  { e=EM_T_NOT_START; return 0;}
        if(s == "EM_T_PREPARE")  { e=EM_T_PREPARE; return 0;}
        if(s == "EM_T_RUNNING")  { e=EM_T_RUNNING; return 0;}
        if(s == "EM_T_SUCCESS")  { e=EM_T_SUCCESS; return 0;}
        if(s == "EM_T_FAILED")  { e=EM_T_FAILED; return 0;}
        if(s == "EM_T_CANCEL")  { e=EM_T_CANCEL; return 0;}
        if(s == "EM_T_PARIAL")  { e=EM_T_PARIAL; return 0;}

        return -1;
    }

    enum EMTaskItemStatus
    {
        EM_I_NOT_START,
        EM_I_PREPARE,
        EM_I_RUNNING,
        EM_I_SUCCESS,
        EM_I_FAILED,
        EM_I_CANCEL,
        EM_I_PAUSE_FLOW,
    };
    inline string etos(const EMTaskItemStatus & e)
    {
        switch(e)
        {
            case EM_I_NOT_START: return "EM_I_NOT_START";
            case EM_I_PREPARE: return "EM_I_PREPARE";
            case EM_I_RUNNING: return "EM_I_RUNNING";
            case EM_I_SUCCESS: return "EM_I_SUCCESS";
            case EM_I_FAILED: return "EM_I_FAILED";
            case EM_I_CANCEL: return "EM_I_CANCEL";
            case EM_I_PAUSE_FLOW: return "EM_I_PAUSE_FLOW";
            default: return "";
        }
    }
    inline int stoe(const string & s, EMTaskItemStatus & e)
    {
        if(s == "EM_I_NOT_START")  { e=EM_I_NOT_START; return 0;}
        if(s == "EM_I_PREPARE")  { e=EM_I_PREPARE; return 0;}
        if(s == "EM_I_RUNNING")  { e=EM_I_RUNNING; return 0;}
        if(s == "EM_I_SUCCESS")  { e=EM_I_SUCCESS; return 0;}
        if(s == "EM_I_FAILED")  { e=EM_I_FAILED; return 0;}
        if(s == "EM_I_CANCEL")  { e=EM_I_CANCEL; return 0;}
        if(s == "EM_I_PAUSE_FLOW")  { e=EM_I_PAUSE_FLOW; return 0;}

        return -1;
    }

    struct ServerStateDesc : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.ServerStateDesc";
        }
        static string MD5()
        {
            return "26a898b86ec52b208c13f81a9242fcd3";
        }
        ServerStateDesc()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            settingStateInReg = "";
            presentStateInReg = "";
            presentStateInNode = "";
            processId = 0;
            patchVersion = "";
            patchTime = "";
            patchUser = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(settingStateInReg, 0);
            _os.write(presentStateInReg, 1);
            _os.write(presentStateInNode, 2);
            _os.write(processId, 3);
            _os.write(patchVersion, 4);
            _os.write(patchTime, 5);
            _os.write(patchUser, 6);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(settingStateInReg, 0, true);
            _is.read(presentStateInReg, 1, true);
            _is.read(presentStateInNode, 2, true);
            _is.read(processId, 3, true);
            _is.read(patchVersion, 4, true);
            _is.read(patchTime, 5, true);
            _is.read(patchUser, 6, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["settingStateInReg"] = tars::JsonOutput::writeJson(settingStateInReg);
            p->value["presentStateInReg"] = tars::JsonOutput::writeJson(presentStateInReg);
            p->value["presentStateInNode"] = tars::JsonOutput::writeJson(presentStateInNode);
            p->value["processId"] = tars::JsonOutput::writeJson(processId);
            p->value["patchVersion"] = tars::JsonOutput::writeJson(patchVersion);
            p->value["patchTime"] = tars::JsonOutput::writeJson(patchTime);
            p->value["patchUser"] = tars::JsonOutput::writeJson(patchUser);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(settingStateInReg,pObj->value["settingStateInReg"], true);
            tars::JsonInput::readJson(presentStateInReg,pObj->value["presentStateInReg"], true);
            tars::JsonInput::readJson(presentStateInNode,pObj->value["presentStateInNode"], true);
            tars::JsonInput::readJson(processId,pObj->value["processId"], true);
            tars::JsonInput::readJson(patchVersion,pObj->value["patchVersion"], true);
            tars::JsonInput::readJson(patchTime,pObj->value["patchTime"], true);
            tars::JsonInput::readJson(patchUser,pObj->value["patchUser"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(settingStateInReg,"settingStateInReg");
            _ds.display(presentStateInReg,"presentStateInReg");
            _ds.display(presentStateInNode,"presentStateInNode");
            _ds.display(processId,"processId");
            _ds.display(patchVersion,"patchVersion");
            _ds.display(patchTime,"patchTime");
            _ds.display(patchUser,"patchUser");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(settingStateInReg, true);
            _ds.displaySimple(presentStateInReg, true);
            _ds.displaySimple(presentStateInNode, true);
            _ds.displaySimple(processId, true);
            _ds.displaySimple(patchVersion, true);
            _ds.displaySimple(patchTime, true);
            _ds.displaySimple(patchUser, false);
            return _os;
        }
    public:
        std::string settingStateInReg;
        std::string presentStateInReg;
        std::string presentStateInNode;
        tars::Int32 processId;
        std::string patchVersion;
        std::string patchTime;
        std::string patchUser;
    };
    inline bool operator==(const ServerStateDesc&l, const ServerStateDesc&r)
    {
        return l.settingStateInReg == r.settingStateInReg && l.presentStateInReg == r.presentStateInReg && l.presentStateInNode == r.presentStateInNode && l.processId == r.processId && l.patchVersion == r.patchVersion && l.patchTime == r.patchTime && l.patchUser == r.patchUser;
    }
    inline bool operator!=(const ServerStateDesc&l, const ServerStateDesc&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ServerStateDesc&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ServerStateDesc&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TaskItemReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.TaskItemReq";
        }
        static string MD5()
        {
            return "81985ab5572d614277b48adc89fb3c33";
        }
        TaskItemReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            taskNo = "";
            itemNo = "";
            application = "";
            serverName = "";
            nodeName = "";
            setName = "";
            command = "";
            userName = "";
            parameters.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (taskNo != "")
            {
                _os.write(taskNo, 0);
            }
            if (itemNo != "")
            {
                _os.write(itemNo, 1);
            }
            if (application != "")
            {
                _os.write(application, 2);
            }
            if (serverName != "")
            {
                _os.write(serverName, 3);
            }
            if (nodeName != "")
            {
                _os.write(nodeName, 4);
            }
            if (setName != "")
            {
                _os.write(setName, 5);
            }
            if (command != "")
            {
                _os.write(command, 6);
            }
            if (userName != "")
            {
                _os.write(userName, 7);
            }
            if (parameters.size() > 0)
            {
                _os.write(parameters, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(taskNo, 0, false);
            _is.read(itemNo, 1, false);
            _is.read(application, 2, false);
            _is.read(serverName, 3, false);
            _is.read(nodeName, 4, false);
            _is.read(setName, 5, false);
            _is.read(command, 6, false);
            _is.read(userName, 7, false);
            _is.read(parameters, 8, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["taskNo"] = tars::JsonOutput::writeJson(taskNo);
            p->value["itemNo"] = tars::JsonOutput::writeJson(itemNo);
            p->value["application"] = tars::JsonOutput::writeJson(application);
            p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
            p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
            p->value["setName"] = tars::JsonOutput::writeJson(setName);
            p->value["command"] = tars::JsonOutput::writeJson(command);
            p->value["userName"] = tars::JsonOutput::writeJson(userName);
            p->value["parameters"] = tars::JsonOutput::writeJson(parameters);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(taskNo,pObj->value["taskNo"], false);
            tars::JsonInput::readJson(itemNo,pObj->value["itemNo"], false);
            tars::JsonInput::readJson(application,pObj->value["application"], false);
            tars::JsonInput::readJson(serverName,pObj->value["serverName"], false);
            tars::JsonInput::readJson(nodeName,pObj->value["nodeName"], false);
            tars::JsonInput::readJson(setName,pObj->value["setName"], false);
            tars::JsonInput::readJson(command,pObj->value["command"], false);
            tars::JsonInput::readJson(userName,pObj->value["userName"], false);
            tars::JsonInput::readJson(parameters,pObj->value["parameters"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(taskNo,"taskNo");
            _ds.display(itemNo,"itemNo");
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            _ds.display(nodeName,"nodeName");
            _ds.display(setName,"setName");
            _ds.display(command,"command");
            _ds.display(userName,"userName");
            _ds.display(parameters,"parameters");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(taskNo, true);
            _ds.displaySimple(itemNo, true);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(setName, true);
            _ds.displaySimple(command, true);
            _ds.displaySimple(userName, true);
            _ds.displaySimple(parameters, false);
            return _os;
        }
    public:
        std::string taskNo;
        std::string itemNo;
        std::string application;
        std::string serverName;
        std::string nodeName;
        std::string setName;
        std::string command;
        std::string userName;
        map<std::string, std::string> parameters;
    };
    inline bool operator==(const TaskItemReq&l, const TaskItemReq&r)
    {
        return l.taskNo == r.taskNo && l.itemNo == r.itemNo && l.application == r.application && l.serverName == r.serverName && l.nodeName == r.nodeName && l.setName == r.setName && l.command == r.command && l.userName == r.userName && l.parameters == r.parameters;
    }
    inline bool operator!=(const TaskItemReq&l, const TaskItemReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TaskItemReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TaskItemReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TaskItemRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.TaskItemRsp";
        }
        static string MD5()
        {
            return "d910af657d41a7bd407c1e3538b6fc11";
        }
        TaskItemRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            req.resetDefautlt();
            startTime = "";
            endTime = "";
            status = tars::EM_I_NOT_START;
            statusInfo = "";
            executeLog = "";
            percent = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(req, 0);
            if (startTime != "")
            {
                _os.write(startTime, 1);
            }
            if (endTime != "")
            {
                _os.write(endTime, 2);
            }
            _os.write((tars::Int32)status, 3);
            if (statusInfo != "")
            {
                _os.write(statusInfo, 4);
            }
            if (executeLog != "")
            {
                _os.write(executeLog, 5);
            }
            if (percent != 0)
            {
                _os.write(percent, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(req, 0, false);
            _is.read(startTime, 1, false);
            _is.read(endTime, 2, false);
            tars::Int32 eTemp3 = tars::EM_I_NOT_START;
            _is.read(eTemp3, 3, false);
            status = (tars::EMTaskItemStatus)eTemp3;
            _is.read(statusInfo, 4, false);
            _is.read(executeLog, 5, false);
            _is.read(percent, 6, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["req"] = tars::JsonOutput::writeJson(req);
            p->value["startTime"] = tars::JsonOutput::writeJson(startTime);
            p->value["endTime"] = tars::JsonOutput::writeJson(endTime);
            p->value["status"] = tars::JsonOutput::writeJson((tars::Int32)status);
            p->value["statusInfo"] = tars::JsonOutput::writeJson(statusInfo);
            p->value["executeLog"] = tars::JsonOutput::writeJson(executeLog);
            p->value["percent"] = tars::JsonOutput::writeJson(percent);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(req,pObj->value["req"], false);
            tars::JsonInput::readJson(startTime,pObj->value["startTime"], false);
            tars::JsonInput::readJson(endTime,pObj->value["endTime"], false);
            tars::JsonInput::readJson(status,pObj->value["status"], false);
            tars::JsonInput::readJson(statusInfo,pObj->value["statusInfo"], false);
            tars::JsonInput::readJson(executeLog,pObj->value["executeLog"], false);
            tars::JsonInput::readJson(percent,pObj->value["percent"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(req,"req");
            _ds.display(startTime,"startTime");
            _ds.display(endTime,"endTime");
            _ds.display((tars::Int32)status,"status");
            _ds.display(statusInfo,"statusInfo");
            _ds.display(executeLog,"executeLog");
            _ds.display(percent,"percent");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(req, true);
            _ds.displaySimple(startTime, true);
            _ds.displaySimple(endTime, true);
            _ds.displaySimple((tars::Int32)status, true);
            _ds.displaySimple(statusInfo, true);
            _ds.displaySimple(executeLog, true);
            _ds.displaySimple(percent, false);
            return _os;
        }
    public:
        tars::TaskItemReq req;
        std::string startTime;
        std::string endTime;
        tars::EMTaskItemStatus status;
        std::string statusInfo;
        std::string executeLog;
        tars::Int32 percent;
    };
    inline bool operator==(const TaskItemRsp&l, const TaskItemRsp&r)
    {
        return l.req == r.req && l.startTime == r.startTime && l.endTime == r.endTime && l.status == r.status && l.statusInfo == r.statusInfo && l.executeLog == r.executeLog && l.percent == r.percent;
    }
    inline bool operator!=(const TaskItemRsp&l, const TaskItemRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TaskItemRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TaskItemRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TaskReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.TaskReq";
        }
        static string MD5()
        {
            return "42154abaeb70f2492b376cecfb41d05b";
        }
        TaskReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            taskItemReq.clear();
            taskNo = "";
            serial = true;
            userName = "";
            isElegant = false;
            eachNum = 1;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (taskItemReq.size() > 0)
            {
                _os.write(taskItemReq, 0);
            }
            if (taskNo != "")
            {
                _os.write(taskNo, 1);
            }
            if (serial != true)
            {
                _os.write(serial, 2);
            }
            if (userName != "")
            {
                _os.write(userName, 3);
            }
            if (isElegant != false)
            {
                _os.write(isElegant, 4);
            }
            if (eachNum != 1)
            {
                _os.write(eachNum, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(taskItemReq, 0, false);
            _is.read(taskNo, 1, false);
            _is.read(serial, 2, false);
            _is.read(userName, 3, false);
            _is.read(isElegant, 4, false);
            _is.read(eachNum, 5, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["taskItemReq"] = tars::JsonOutput::writeJson(taskItemReq);
            p->value["taskNo"] = tars::JsonOutput::writeJson(taskNo);
            p->value["serial"] = tars::JsonOutput::writeJson(serial);
            p->value["userName"] = tars::JsonOutput::writeJson(userName);
            p->value["isElegant"] = tars::JsonOutput::writeJson(isElegant);
            p->value["eachNum"] = tars::JsonOutput::writeJson(eachNum);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(taskItemReq,pObj->value["taskItemReq"], false);
            tars::JsonInput::readJson(taskNo,pObj->value["taskNo"], false);
            tars::JsonInput::readJson(serial,pObj->value["serial"], false);
            tars::JsonInput::readJson(userName,pObj->value["userName"], false);
            tars::JsonInput::readJson(isElegant,pObj->value["isElegant"], false);
            tars::JsonInput::readJson(eachNum,pObj->value["eachNum"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(taskItemReq,"taskItemReq");
            _ds.display(taskNo,"taskNo");
            _ds.display(serial,"serial");
            _ds.display(userName,"userName");
            _ds.display(isElegant,"isElegant");
            _ds.display(eachNum,"eachNum");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(taskItemReq, true);
            _ds.displaySimple(taskNo, true);
            _ds.displaySimple(serial, true);
            _ds.displaySimple(userName, true);
            _ds.displaySimple(isElegant, true);
            _ds.displaySimple(eachNum, false);
            return _os;
        }
    public:
        vector<tars::TaskItemReq> taskItemReq;
        std::string taskNo;
        tars::Bool serial;
        std::string userName;
        tars::Bool isElegant;
        tars::Int32 eachNum;
    };
    inline bool operator==(const TaskReq&l, const TaskReq&r)
    {
        return l.taskItemReq == r.taskItemReq && l.taskNo == r.taskNo && l.serial == r.serial && l.userName == r.userName && l.isElegant == r.isElegant && l.eachNum == r.eachNum;
    }
    inline bool operator!=(const TaskReq&l, const TaskReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TaskReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TaskReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TaskRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.TaskRsp";
        }
        static string MD5()
        {
            return "bf3f62de982fffff8fcb5501a6b10b9c";
        }
        TaskRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            taskItemRsp.clear();
            taskNo = "";
            serial = true;
            userName = "";
            status = tars::EM_T_NOT_START;
            createTime = "";
            executeLog = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (taskItemRsp.size() > 0)
            {
                _os.write(taskItemRsp, 0);
            }
            if (taskNo != "")
            {
                _os.write(taskNo, 1);
            }
            if (serial != true)
            {
                _os.write(serial, 2);
            }
            if (userName != "")
            {
                _os.write(userName, 3);
            }
            _os.write((tars::Int32)status, 4);
            if (createTime != "")
            {
                _os.write(createTime, 5);
            }
            if (executeLog != "")
            {
                _os.write(executeLog, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(taskItemRsp, 0, false);
            _is.read(taskNo, 1, false);
            _is.read(serial, 2, false);
            _is.read(userName, 3, false);
            tars::Int32 eTemp4 = tars::EM_T_NOT_START;
            _is.read(eTemp4, 4, false);
            status = (tars::EMTaskStatus)eTemp4;
            _is.read(createTime, 5, false);
            _is.read(executeLog, 6, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["taskItemRsp"] = tars::JsonOutput::writeJson(taskItemRsp);
            p->value["taskNo"] = tars::JsonOutput::writeJson(taskNo);
            p->value["serial"] = tars::JsonOutput::writeJson(serial);
            p->value["userName"] = tars::JsonOutput::writeJson(userName);
            p->value["status"] = tars::JsonOutput::writeJson((tars::Int32)status);
            p->value["createTime"] = tars::JsonOutput::writeJson(createTime);
            p->value["executeLog"] = tars::JsonOutput::writeJson(executeLog);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(taskItemRsp,pObj->value["taskItemRsp"], false);
            tars::JsonInput::readJson(taskNo,pObj->value["taskNo"], false);
            tars::JsonInput::readJson(serial,pObj->value["serial"], false);
            tars::JsonInput::readJson(userName,pObj->value["userName"], false);
            tars::JsonInput::readJson(status,pObj->value["status"], false);
            tars::JsonInput::readJson(createTime,pObj->value["createTime"], false);
            tars::JsonInput::readJson(executeLog,pObj->value["executeLog"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(taskItemRsp,"taskItemRsp");
            _ds.display(taskNo,"taskNo");
            _ds.display(serial,"serial");
            _ds.display(userName,"userName");
            _ds.display((tars::Int32)status,"status");
            _ds.display(createTime,"createTime");
            _ds.display(executeLog,"executeLog");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(taskItemRsp, true);
            _ds.displaySimple(taskNo, true);
            _ds.displaySimple(serial, true);
            _ds.displaySimple(userName, true);
            _ds.displaySimple((tars::Int32)status, true);
            _ds.displaySimple(createTime, true);
            _ds.displaySimple(executeLog, false);
            return _os;
        }
    public:
        vector<tars::TaskItemRsp> taskItemRsp;
        std::string taskNo;
        tars::Bool serial;
        std::string userName;
        tars::EMTaskStatus status;
        std::string createTime;
        std::string executeLog;
    };
    inline bool operator==(const TaskRsp&l, const TaskRsp&r)
    {
        return l.taskItemRsp == r.taskItemRsp && l.taskNo == r.taskNo && l.serial == r.serial && l.userName == r.userName && l.status == r.status && l.createTime == r.createTime && l.executeLog == r.executeLog;
    }
    inline bool operator!=(const TaskRsp&l, const TaskRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TaskRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TaskRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct FrameworkServer : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.FrameworkServer";
        }
        static string MD5()
        {
            return "0c1d945735360d4e3752e1b2d448ba0c";
        }
        FrameworkServer()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            serverName = "";
            nodeName = "";
            objName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(serverName, 0);
            _os.write(nodeName, 1);
            _os.write(objName, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(serverName, 0, true);
            _is.read(nodeName, 1, true);
            _is.read(objName, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
            p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
            p->value["objName"] = tars::JsonOutput::writeJson(objName);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(serverName,pObj->value["serverName"], true);
            tars::JsonInput::readJson(nodeName,pObj->value["nodeName"], true);
            tars::JsonInput::readJson(objName,pObj->value["objName"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(serverName,"serverName");
            _ds.display(nodeName,"nodeName");
            _ds.display(objName,"objName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(objName, false);
            return _os;
        }
    public:
        std::string serverName;
        std::string nodeName;
        std::string objName;
    };
    inline bool operator==(const FrameworkServer&l, const FrameworkServer&r)
    {
        return l.serverName == r.serverName && l.nodeName == r.nodeName && l.objName == r.objName;
    }
    inline bool operator!=(const FrameworkServer&l, const FrameworkServer&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const FrameworkServer&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,FrameworkServer&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ServerConf : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.ServerConf";
        }
        static string MD5()
        {
            return "d74ab1491257679c0e384ce71763fb14";
        }
        ServerConf()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            application = "";
            serverName = "";
            nodeName = "";
            basePath = "";
            exePath = "";
            settingState = "active";
            profile = "";
            serverType = "";
            startScript = "";
            stopScript = "";
            monitorScript = "";
            asyncThreadNum = 3;
            enableGroup = "M";
            ipGroupName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (application != "")
            {
                _os.write(application, 0);
            }
            if (serverName != "")
            {
                _os.write(serverName, 1);
            }
            if (nodeName != "")
            {
                _os.write(nodeName, 2);
            }
            if (basePath != "")
            {
                _os.write(basePath, 3);
            }
            if (exePath != "")
            {
                _os.write(exePath, 4);
            }
            if (settingState != "active")
            {
                _os.write(settingState, 5);
            }
            if (profile != "")
            {
                _os.write(profile, 6);
            }
            if (serverType != "")
            {
                _os.write(serverType, 7);
            }
            if (startScript != "")
            {
                _os.write(startScript, 8);
            }
            if (stopScript != "")
            {
                _os.write(stopScript, 9);
            }
            if (monitorScript != "")
            {
                _os.write(monitorScript, 10);
            }
            if (asyncThreadNum != 3)
            {
                _os.write(asyncThreadNum, 11);
            }
            if (enableGroup != "M")
            {
                _os.write(enableGroup, 12);
            }
            if (ipGroupName != "")
            {
                _os.write(ipGroupName, 13);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(application, 0, false);
            _is.read(serverName, 1, false);
            _is.read(nodeName, 2, false);
            _is.read(basePath, 3, false);
            _is.read(exePath, 4, false);
            _is.read(settingState, 5, false);
            _is.read(profile, 6, false);
            _is.read(serverType, 7, false);
            _is.read(startScript, 8, false);
            _is.read(stopScript, 9, false);
            _is.read(monitorScript, 10, false);
            _is.read(asyncThreadNum, 11, false);
            _is.read(enableGroup, 12, false);
            _is.read(ipGroupName, 13, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["application"] = tars::JsonOutput::writeJson(application);
            p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
            p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
            p->value["basePath"] = tars::JsonOutput::writeJson(basePath);
            p->value["exePath"] = tars::JsonOutput::writeJson(exePath);
            p->value["settingState"] = tars::JsonOutput::writeJson(settingState);
            p->value["profile"] = tars::JsonOutput::writeJson(profile);
            p->value["serverType"] = tars::JsonOutput::writeJson(serverType);
            p->value["startScript"] = tars::JsonOutput::writeJson(startScript);
            p->value["stopScript"] = tars::JsonOutput::writeJson(stopScript);
            p->value["monitorScript"] = tars::JsonOutput::writeJson(monitorScript);
            p->value["asyncThreadNum"] = tars::JsonOutput::writeJson(asyncThreadNum);
            p->value["enableGroup"] = tars::JsonOutput::writeJson(enableGroup);
            p->value["ipGroupName"] = tars::JsonOutput::writeJson(ipGroupName);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(application,pObj->value["application"], false);
            tars::JsonInput::readJson(serverName,pObj->value["serverName"], false);
            tars::JsonInput::readJson(nodeName,pObj->value["nodeName"], false);
            tars::JsonInput::readJson(basePath,pObj->value["basePath"], false);
            tars::JsonInput::readJson(exePath,pObj->value["exePath"], false);
            tars::JsonInput::readJson(settingState,pObj->value["settingState"], false);
            tars::JsonInput::readJson(profile,pObj->value["profile"], false);
            tars::JsonInput::readJson(serverType,pObj->value["serverType"], false);
            tars::JsonInput::readJson(startScript,pObj->value["startScript"], false);
            tars::JsonInput::readJson(stopScript,pObj->value["stopScript"], false);
            tars::JsonInput::readJson(monitorScript,pObj->value["monitorScript"], false);
            tars::JsonInput::readJson(asyncThreadNum,pObj->value["asyncThreadNum"], false);
            tars::JsonInput::readJson(enableGroup,pObj->value["enableGroup"], false);
            tars::JsonInput::readJson(ipGroupName,pObj->value["ipGroupName"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            _ds.display(nodeName,"nodeName");
            _ds.display(basePath,"basePath");
            _ds.display(exePath,"exePath");
            _ds.display(settingState,"settingState");
            _ds.display(profile,"profile");
            _ds.display(serverType,"serverType");
            _ds.display(startScript,"startScript");
            _ds.display(stopScript,"stopScript");
            _ds.display(monitorScript,"monitorScript");
            _ds.display(asyncThreadNum,"asyncThreadNum");
            _ds.display(enableGroup,"enableGroup");
            _ds.display(ipGroupName,"ipGroupName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(basePath, true);
            _ds.displaySimple(exePath, true);
            _ds.displaySimple(settingState, true);
            _ds.displaySimple(profile, true);
            _ds.displaySimple(serverType, true);
            _ds.displaySimple(startScript, true);
            _ds.displaySimple(stopScript, true);
            _ds.displaySimple(monitorScript, true);
            _ds.displaySimple(asyncThreadNum, true);
            _ds.displaySimple(enableGroup, true);
            _ds.displaySimple(ipGroupName, false);
            return _os;
        }
    public:
        std::string application;
        std::string serverName;
        std::string nodeName;
        std::string basePath;
        std::string exePath;
        std::string settingState;
        std::string profile;
        std::string serverType;
        std::string startScript;
        std::string stopScript;
        std::string monitorScript;
        tars::Int32 asyncThreadNum;
        std::string enableGroup;
        std::string ipGroupName;
    };
    inline bool operator==(const ServerConf&l, const ServerConf&r)
    {
        return l.application == r.application && l.serverName == r.serverName && l.nodeName == r.nodeName && l.basePath == r.basePath && l.exePath == r.exePath && l.settingState == r.settingState && l.profile == r.profile && l.serverType == r.serverType && l.startScript == r.startScript && l.stopScript == r.stopScript && l.monitorScript == r.monitorScript && l.asyncThreadNum == r.asyncThreadNum && l.enableGroup == r.enableGroup && l.ipGroupName == r.ipGroupName;
    }
    inline bool operator!=(const ServerConf&l, const ServerConf&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ServerConf&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ServerConf&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AdapterConf : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.AdapterConf";
        }
        static string MD5()
        {
            return "b13dd559792c9b7b93b931d140d8dde1";
        }
        AdapterConf()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            adapterName = "";
            threadNum = 5;
            endpoint = "";
            maxConnections = 10240;
            allowIp = "";
            servant = "";
            queuecap = 100000;
            queuetimeout = 600000;
            protocol = "tars";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (adapterName != "")
            {
                _os.write(adapterName, 0);
            }
            if (threadNum != 5)
            {
                _os.write(threadNum, 1);
            }
            if (endpoint != "")
            {
                _os.write(endpoint, 2);
            }
            if (maxConnections != 10240)
            {
                _os.write(maxConnections, 3);
            }
            if (allowIp != "")
            {
                _os.write(allowIp, 4);
            }
            if (servant != "")
            {
                _os.write(servant, 5);
            }
            if (queuecap != 100000)
            {
                _os.write(queuecap, 6);
            }
            if (queuetimeout != 600000)
            {
                _os.write(queuetimeout, 7);
            }
            if (protocol != "tars")
            {
                _os.write(protocol, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(adapterName, 0, false);
            _is.read(threadNum, 1, false);
            _is.read(endpoint, 2, false);
            _is.read(maxConnections, 3, false);
            _is.read(allowIp, 4, false);
            _is.read(servant, 5, false);
            _is.read(queuecap, 6, false);
            _is.read(queuetimeout, 7, false);
            _is.read(protocol, 8, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["adapterName"] = tars::JsonOutput::writeJson(adapterName);
            p->value["threadNum"] = tars::JsonOutput::writeJson(threadNum);
            p->value["endpoint"] = tars::JsonOutput::writeJson(endpoint);
            p->value["maxConnections"] = tars::JsonOutput::writeJson(maxConnections);
            p->value["allowIp"] = tars::JsonOutput::writeJson(allowIp);
            p->value["servant"] = tars::JsonOutput::writeJson(servant);
            p->value["queuecap"] = tars::JsonOutput::writeJson(queuecap);
            p->value["queuetimeout"] = tars::JsonOutput::writeJson(queuetimeout);
            p->value["protocol"] = tars::JsonOutput::writeJson(protocol);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(adapterName,pObj->value["adapterName"], false);
            tars::JsonInput::readJson(threadNum,pObj->value["threadNum"], false);
            tars::JsonInput::readJson(endpoint,pObj->value["endpoint"], false);
            tars::JsonInput::readJson(maxConnections,pObj->value["maxConnections"], false);
            tars::JsonInput::readJson(allowIp,pObj->value["allowIp"], false);
            tars::JsonInput::readJson(servant,pObj->value["servant"], false);
            tars::JsonInput::readJson(queuecap,pObj->value["queuecap"], false);
            tars::JsonInput::readJson(queuetimeout,pObj->value["queuetimeout"], false);
            tars::JsonInput::readJson(protocol,pObj->value["protocol"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(adapterName,"adapterName");
            _ds.display(threadNum,"threadNum");
            _ds.display(endpoint,"endpoint");
            _ds.display(maxConnections,"maxConnections");
            _ds.display(allowIp,"allowIp");
            _ds.display(servant,"servant");
            _ds.display(queuecap,"queuecap");
            _ds.display(queuetimeout,"queuetimeout");
            _ds.display(protocol,"protocol");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(adapterName, true);
            _ds.displaySimple(threadNum, true);
            _ds.displaySimple(endpoint, true);
            _ds.displaySimple(maxConnections, true);
            _ds.displaySimple(allowIp, true);
            _ds.displaySimple(servant, true);
            _ds.displaySimple(queuecap, true);
            _ds.displaySimple(queuetimeout, true);
            _ds.displaySimple(protocol, false);
            return _os;
        }
    public:
        std::string adapterName;
        tars::Int32 threadNum;
        std::string endpoint;
        tars::Int32 maxConnections;
        std::string allowIp;
        std::string servant;
        tars::Int32 queuecap;
        tars::Int32 queuetimeout;
        std::string protocol;
    };
    inline bool operator==(const AdapterConf&l, const AdapterConf&r)
    {
        return l.adapterName == r.adapterName && l.threadNum == r.threadNum && l.endpoint == r.endpoint && l.maxConnections == r.maxConnections && l.allowIp == r.allowIp && l.servant == r.servant && l.queuecap == r.queuecap && l.queuetimeout == r.queuetimeout && l.protocol == r.protocol;
    }
    inline bool operator!=(const AdapterConf&l, const AdapterConf&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AdapterConf&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AdapterConf&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct PluginConf : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.PluginConf";
        }
        static string MD5()
        {
            return "8b851e4fde1f1c13a6ceac49e1f3fc73";
        }
        PluginConf()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            name = "";
            name_en = "";
            obj = "";
            type = 0;
            path = "";
            k8s = false;
            fextern = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (name != "")
            {
                _os.write(name, 0);
            }
            if (name_en != "")
            {
                _os.write(name_en, 1);
            }
            if (obj != "")
            {
                _os.write(obj, 2);
            }
            if (type != 0)
            {
                _os.write(type, 3);
            }
            if (path != "")
            {
                _os.write(path, 4);
            }
            if (k8s != false)
            {
                _os.write(k8s, 5);
            }
            if (fextern != 0)
            {
                _os.write(fextern, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(name, 0, false);
            _is.read(name_en, 1, false);
            _is.read(obj, 2, false);
            _is.read(type, 3, false);
            _is.read(path, 4, false);
            _is.read(k8s, 5, false);
            _is.read(fextern, 6, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["name"] = tars::JsonOutput::writeJson(name);
            p->value["name_en"] = tars::JsonOutput::writeJson(name_en);
            p->value["obj"] = tars::JsonOutput::writeJson(obj);
            p->value["type"] = tars::JsonOutput::writeJson(type);
            p->value["path"] = tars::JsonOutput::writeJson(path);
            p->value["k8s"] = tars::JsonOutput::writeJson(k8s);
            p->value["fextern"] = tars::JsonOutput::writeJson(fextern);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(name,pObj->value["name"], false);
            tars::JsonInput::readJson(name_en,pObj->value["name_en"], false);
            tars::JsonInput::readJson(obj,pObj->value["obj"], false);
            tars::JsonInput::readJson(type,pObj->value["type"], false);
            tars::JsonInput::readJson(path,pObj->value["path"], false);
            tars::JsonInput::readJson(k8s,pObj->value["k8s"], false);
            tars::JsonInput::readJson(fextern,pObj->value["fextern"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(name,"name");
            _ds.display(name_en,"name_en");
            _ds.display(obj,"obj");
            _ds.display(type,"type");
            _ds.display(path,"path");
            _ds.display(k8s,"k8s");
            _ds.display(fextern,"fextern");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(name, true);
            _ds.displaySimple(name_en, true);
            _ds.displaySimple(obj, true);
            _ds.displaySimple(type, true);
            _ds.displaySimple(path, true);
            _ds.displaySimple(k8s, true);
            _ds.displaySimple(fextern, false);
            return _os;
        }
    public:
        std::string name;
        std::string name_en;
        std::string obj;
        tars::Int32 type;
        std::string path;
        tars::Bool k8s;
        tars::Int32 fextern;
    };
    inline bool operator==(const PluginConf&l, const PluginConf&r)
    {
        return l.name == r.name && l.name_en == r.name_en && l.obj == r.obj && l.type == r.type && l.path == r.path && l.k8s == r.k8s && l.fextern == r.fextern;
    }
    inline bool operator!=(const PluginConf&l, const PluginConf&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const PluginConf&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,PluginConf&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ServerTree : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.ServerTree";
        }
        static string MD5()
        {
            return "6cf1348cdd69f924109dd734bc911528";
        }
        ServerTree()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            application = "";
            server_name = "";
            enable_set = "";
            set_name = "";
            set_area = "";
            set_group = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (application != "")
            {
                _os.write(application, 0);
            }
            if (server_name != "")
            {
                _os.write(server_name, 1);
            }
            if (enable_set != "")
            {
                _os.write(enable_set, 2);
            }
            if (set_name != "")
            {
                _os.write(set_name, 3);
            }
            if (set_area != "")
            {
                _os.write(set_area, 4);
            }
            if (set_group != "")
            {
                _os.write(set_group, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(application, 0, false);
            _is.read(server_name, 1, false);
            _is.read(enable_set, 2, false);
            _is.read(set_name, 3, false);
            _is.read(set_area, 4, false);
            _is.read(set_group, 5, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["application"] = tars::JsonOutput::writeJson(application);
            p->value["server_name"] = tars::JsonOutput::writeJson(server_name);
            p->value["enable_set"] = tars::JsonOutput::writeJson(enable_set);
            p->value["set_name"] = tars::JsonOutput::writeJson(set_name);
            p->value["set_area"] = tars::JsonOutput::writeJson(set_area);
            p->value["set_group"] = tars::JsonOutput::writeJson(set_group);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(application,pObj->value["application"], false);
            tars::JsonInput::readJson(server_name,pObj->value["server_name"], false);
            tars::JsonInput::readJson(enable_set,pObj->value["enable_set"], false);
            tars::JsonInput::readJson(set_name,pObj->value["set_name"], false);
            tars::JsonInput::readJson(set_area,pObj->value["set_area"], false);
            tars::JsonInput::readJson(set_group,pObj->value["set_group"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(application,"application");
            _ds.display(server_name,"server_name");
            _ds.display(enable_set,"enable_set");
            _ds.display(set_name,"set_name");
            _ds.display(set_area,"set_area");
            _ds.display(set_group,"set_group");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(application, true);
            _ds.displaySimple(server_name, true);
            _ds.displaySimple(enable_set, true);
            _ds.displaySimple(set_name, true);
            _ds.displaySimple(set_area, true);
            _ds.displaySimple(set_group, false);
            return _os;
        }
    public:
        std::string application;
        std::string server_name;
        std::string enable_set;
        std::string set_name;
        std::string set_area;
        std::string set_group;
    };
    inline bool operator==(const ServerTree&l, const ServerTree&r)
    {
        return l.application == r.application && l.server_name == r.server_name && l.enable_set == r.enable_set && l.set_name == r.set_name && l.set_area == r.set_area && l.set_group == r.set_group;
    }
    inline bool operator!=(const ServerTree&l, const ServerTree&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ServerTree&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ServerTree&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct PatchPackage : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.PatchPackage";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        PatchPackage()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            id = 0;
            md5 = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (id != 0)
            {
                _os.write(id, 0);
            }
            if (md5 != "")
            {
                _os.write(md5, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(id, 0, false);
            _is.read(md5, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["id"] = tars::JsonOutput::writeJson(id);
            p->value["md5"] = tars::JsonOutput::writeJson(md5);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(id,pObj->value["id"], false);
            tars::JsonInput::readJson(md5,pObj->value["md5"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(id,"id");
            _ds.display(md5,"md5");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(id, true);
            _ds.displaySimple(md5, false);
            return _os;
        }
    public:
        tars::Int32 id;
        std::string md5;
    };
    inline bool operator==(const PatchPackage&l, const PatchPackage&r)
    {
        return l.id == r.id && l.md5 == r.md5;
    }
    inline bool operator!=(const PatchPackage&l, const PatchPackage&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const PatchPackage&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,PatchPackage&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ApplicationServerName : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.ApplicationServerName";
        }
        static string MD5()
        {
            return "325d87d477a8cf7a6468ed6bb39da964";
        }
        ApplicationServerName()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            application = "";
            serverName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (application != "")
            {
                _os.write(application, 0);
            }
            if (serverName != "")
            {
                _os.write(serverName, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(application, 0, false);
            _is.read(serverName, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["application"] = tars::JsonOutput::writeJson(application);
            p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(application,pObj->value["application"], false);
            tars::JsonInput::readJson(serverName,pObj->value["serverName"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, false);
            return _os;
        }
    public:
        std::string application;
        std::string serverName;
    };
    inline bool operator==(const ApplicationServerName&l, const ApplicationServerName&r)
    {
        return l.application == r.application && l.serverName == r.serverName;
    }
    inline bool operator!=(const ApplicationServerName&l, const ApplicationServerName&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ApplicationServerName&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ApplicationServerName&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


    /* callback of async proxy for client */
    class AdminRegPrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~AdminRegPrxCallback(){}
        virtual void callback_addTaskReq(tars::Int32 ret)
        { throw std::runtime_error("callback_addTaskReq() override incorrect."); }
        virtual void callback_addTaskReq_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_addTaskReq_exception() override incorrect."); }

        virtual void callback_batchPatch(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_batchPatch() override incorrect."); }
        virtual void callback_batchPatch_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_batchPatch_exception() override incorrect."); }
        virtual void callback_batchPatch(tars::Int32 ret, std::string&&  result)
        { callback_batchPatch(ret, result); }

        virtual void callback_checkDockerRegistry(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_checkDockerRegistry() override incorrect."); }
        virtual void callback_checkDockerRegistry_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_checkDockerRegistry_exception() override incorrect."); }
        virtual void callback_checkDockerRegistry(tars::Int32 ret, std::string&&  result)
        { callback_checkDockerRegistry(ret, result); }

        virtual void callback_checkServer(tars::Int32 ret)
        { throw std::runtime_error("callback_checkServer() override incorrect."); }
        virtual void callback_checkServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_checkServer_exception() override incorrect."); }

        virtual void callback_checkTicket(tars::Int32 ret,  const std::string& uid)
        { throw std::runtime_error("callback_checkTicket() override incorrect."); }
        virtual void callback_checkTicket_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_checkTicket_exception() override incorrect."); }
        virtual void callback_checkTicket(tars::Int32 ret, std::string&&  uid)
        { callback_checkTicket(ret, uid); }

        virtual void callback_delCache(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_delCache() override incorrect."); }
        virtual void callback_delCache_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_delCache_exception() override incorrect."); }
        virtual void callback_delCache(tars::Int32 ret, std::string&&  result)
        { callback_delCache(ret, result); }

        virtual void callback_deleteNode(tars::Int32 ret)
        { throw std::runtime_error("callback_deleteNode() override incorrect."); }
        virtual void callback_deleteNode_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_deleteNode_exception() override incorrect."); }

        virtual void callback_deletePatchFile(tars::Int32 ret)
        { throw std::runtime_error("callback_deletePatchFile() override incorrect."); }
        virtual void callback_deletePatchFile_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_deletePatchFile_exception() override incorrect."); }

        virtual void callback_destroyServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_destroyServer() override incorrect."); }
        virtual void callback_destroyServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_destroyServer_exception() override incorrect."); }
        virtual void callback_destroyServer(tars::Int32 ret, std::string&&  result)
        { callback_destroyServer(ret, result); }

        virtual void callback_dockerPull(tars::Int32 ret)
        { throw std::runtime_error("callback_dockerPull() override incorrect."); }
        virtual void callback_dockerPull_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_dockerPull_exception() override incorrect."); }

        virtual void callback_forceDockerLogin(tars::Int32 ret,  const vector<std::string>& result)
        { throw std::runtime_error("callback_forceDockerLogin() override incorrect."); }
        virtual void callback_forceDockerLogin_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_forceDockerLogin_exception() override incorrect."); }
        virtual void callback_forceDockerLogin(tars::Int32 ret, vector<std::string>&&  result)
        { callback_forceDockerLogin(ret, result); }

        virtual void callback_getAllApplicationNames(const vector<std::string>& ret,  const std::string& result)
        { throw std::runtime_error("callback_getAllApplicationNames() override incorrect."); }
        virtual void callback_getAllApplicationNames_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getAllApplicationNames_exception() override incorrect."); }
        virtual void callback_getAllApplicationNames(vector<std::string>&& ret, std::string&&  result)
        { callback_getAllApplicationNames(ret, result); }

        virtual void callback_getAllNodeNames(const vector<std::string>& ret,  const std::string& result)
        { throw std::runtime_error("callback_getAllNodeNames() override incorrect."); }
        virtual void callback_getAllNodeNames_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getAllNodeNames_exception() override incorrect."); }
        virtual void callback_getAllNodeNames(vector<std::string>&& ret, std::string&&  result)
        { callback_getAllNodeNames(ret, result); }

        virtual void callback_getAllServerIds(const vector<vector<std::string> >& ret,  const std::string& result)
        { throw std::runtime_error("callback_getAllServerIds() override incorrect."); }
        virtual void callback_getAllServerIds_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getAllServerIds_exception() override incorrect."); }
        virtual void callback_getAllServerIds(vector<vector<std::string> >&& ret, std::string&&  result)
        { callback_getAllServerIds(ret, result); }

        virtual void callback_getClientIp(tars::Int32 ret,  const std::string& sClientIp)
        { throw std::runtime_error("callback_getClientIp() override incorrect."); }
        virtual void callback_getClientIp_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getClientIp_exception() override incorrect."); }
        virtual void callback_getClientIp(tars::Int32 ret, std::string&&  sClientIp)
        { callback_getClientIp(ret, sClientIp); }

        virtual void callback_getConfigFileId(tars::Int32 ret, tars::Int32 configId)
        { throw std::runtime_error("callback_getConfigFileId() override incorrect."); }
        virtual void callback_getConfigFileId_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getConfigFileId_exception() override incorrect."); }

        virtual void callback_getGroupId(tars::Int32 ret, tars::Int32 groupId,  const std::string& result)
        { throw std::runtime_error("callback_getGroupId() override incorrect."); }
        virtual void callback_getGroupId_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getGroupId_exception() override incorrect."); }
        virtual void callback_getGroupId(tars::Int32 ret, tars::Int32 groupId, std::string&&  result)
        { callback_getGroupId(ret, groupId, result); }

        virtual void callback_getLogData(tars::Int32 ret,  const std::string& fileData)
        { throw std::runtime_error("callback_getLogData() override incorrect."); }
        virtual void callback_getLogData_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getLogData_exception() override incorrect."); }
        virtual void callback_getLogData(tars::Int32 ret, std::string&&  fileData)
        { callback_getLogData(ret, fileData); }

        virtual void callback_getLogFileList(tars::Int32 ret,  const vector<std::string>& logFileList)
        { throw std::runtime_error("callback_getLogFileList() override incorrect."); }
        virtual void callback_getLogFileList_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getLogFileList_exception() override incorrect."); }
        virtual void callback_getLogFileList(tars::Int32 ret, vector<std::string>&&  logFileList)
        { callback_getLogFileList(ret, logFileList); }

        virtual void callback_getNodeList(tars::Int32 ret,  const map<std::string, std::string>& heartbeats)
        { throw std::runtime_error("callback_getNodeList() override incorrect."); }
        virtual void callback_getNodeList_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getNodeList_exception() override incorrect."); }
        virtual void callback_getNodeList(tars::Int32 ret, map<std::string, std::string>&&  heartbeats)
        { callback_getNodeList(ret, heartbeats); }

        virtual void callback_getNodeLoad(tars::Int32 ret,  const std::string& fileData)
        { throw std::runtime_error("callback_getNodeLoad() override incorrect."); }
        virtual void callback_getNodeLoad_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getNodeLoad_exception() override incorrect."); }
        virtual void callback_getNodeLoad(tars::Int32 ret, std::string&&  fileData)
        { callback_getNodeLoad(ret, fileData); }

        virtual void callback_getNodeVesion(tars::Int32 ret,  const std::string& version,  const std::string& result)
        { throw std::runtime_error("callback_getNodeVesion() override incorrect."); }
        virtual void callback_getNodeVesion_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getNodeVesion_exception() override incorrect."); }
        virtual void callback_getNodeVesion(tars::Int32 ret, std::string&&  version, std::string&&  result)
        { callback_getNodeVesion(ret, version, result); }

        virtual void callback_getPatchPackage(tars::Int32 ret,  const tars::PatchPackage& pack)
        { throw std::runtime_error("callback_getPatchPackage() override incorrect."); }
        virtual void callback_getPatchPackage_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getPatchPackage_exception() override incorrect."); }
        virtual void callback_getPatchPackage(tars::Int32 ret, tars::PatchPackage&&  pack)
        { callback_getPatchPackage(ret, pack); }

        virtual void callback_getPatchPercent(tars::Int32 ret,  const tars::PatchInfo& tPatchInfo)
        { throw std::runtime_error("callback_getPatchPercent() override incorrect."); }
        virtual void callback_getPatchPercent_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getPatchPercent_exception() override incorrect."); }
        virtual void callback_getPatchPercent(tars::Int32 ret, tars::PatchInfo&&  tPatchInfo)
        { callback_getPatchPercent(ret, tPatchInfo); }

        virtual void callback_getProfileTemplate(tars::Int32 ret,  const std::string& profileTemplate,  const std::string& resultDesc)
        { throw std::runtime_error("callback_getProfileTemplate() override incorrect."); }
        virtual void callback_getProfileTemplate_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getProfileTemplate_exception() override incorrect."); }
        virtual void callback_getProfileTemplate(tars::Int32 ret, std::string&&  profileTemplate, std::string&&  resultDesc)
        { callback_getProfileTemplate(ret, profileTemplate, resultDesc); }

        virtual void callback_getServerNameList(tars::Int32 ret,  const vector<map<std::string, std::string> >& serverList)
        { throw std::runtime_error("callback_getServerNameList() override incorrect."); }
        virtual void callback_getServerNameList_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getServerNameList_exception() override incorrect."); }
        virtual void callback_getServerNameList(tars::Int32 ret, vector<map<std::string, std::string> >&&  serverList)
        { callback_getServerNameList(ret, serverList); }

        virtual void callback_getServerProfileTemplate(tars::Int32 ret,  const std::string& profileTemplate,  const std::string& resultDesc)
        { throw std::runtime_error("callback_getServerProfileTemplate() override incorrect."); }
        virtual void callback_getServerProfileTemplate_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getServerProfileTemplate_exception() override incorrect."); }
        virtual void callback_getServerProfileTemplate(tars::Int32 ret, std::string&&  profileTemplate, std::string&&  resultDesc)
        { callback_getServerProfileTemplate(ret, profileTemplate, resultDesc); }

        virtual void callback_getServerState(tars::Int32 ret,  const tars::ServerStateDesc& state,  const std::string& result)
        { throw std::runtime_error("callback_getServerState() override incorrect."); }
        virtual void callback_getServerState_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getServerState_exception() override incorrect."); }
        virtual void callback_getServerState(tars::Int32 ret, tars::ServerStateDesc&&  state, std::string&&  result)
        { callback_getServerState(ret, state, result); }

        virtual void callback_getServerTree(tars::Int32 ret,  const vector<tars::ServerTree>& tree)
        { throw std::runtime_error("callback_getServerTree() override incorrect."); }
        virtual void callback_getServerTree_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getServerTree_exception() override incorrect."); }
        virtual void callback_getServerTree(tars::Int32 ret, vector<tars::ServerTree>&&  tree)
        { callback_getServerTree(ret, tree); }

        virtual void callback_getServers(tars::Int32 ret,  const vector<tars::FrameworkServer>& servers)
        { throw std::runtime_error("callback_getServers() override incorrect."); }
        virtual void callback_getServers_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getServers_exception() override incorrect."); }
        virtual void callback_getServers(tars::Int32 ret, vector<tars::FrameworkServer>&&  servers)
        { callback_getServers(ret, servers); }

        virtual void callback_getTaskHistory(tars::Int32 ret,  const vector<tars::TaskRsp>& taskRsps)
        { throw std::runtime_error("callback_getTaskHistory() override incorrect."); }
        virtual void callback_getTaskHistory_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getTaskHistory_exception() override incorrect."); }
        virtual void callback_getTaskHistory(tars::Int32 ret, vector<tars::TaskRsp>&&  taskRsps)
        { callback_getTaskHistory(ret, taskRsps); }

        virtual void callback_getTaskRsp(tars::Int32 ret,  const tars::TaskRsp& taskRsp)
        { throw std::runtime_error("callback_getTaskRsp() override incorrect."); }
        virtual void callback_getTaskRsp_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getTaskRsp_exception() override incorrect."); }
        virtual void callback_getTaskRsp(tars::Int32 ret, tars::TaskRsp&&  taskRsp)
        { callback_getTaskRsp(ret, taskRsp); }

        virtual void callback_getVersion(tars::Int32 ret,  const std::string& version)
        { throw std::runtime_error("callback_getVersion() override incorrect."); }
        virtual void callback_getVersion_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getVersion_exception() override incorrect."); }
        virtual void callback_getVersion(tars::Int32 ret, std::string&&  version)
        { callback_getVersion(ret, version); }

        virtual void callback_hasAdminAuth(tars::Int32 ret, tars::Bool has)
        { throw std::runtime_error("callback_hasAdminAuth() override incorrect."); }
        virtual void callback_hasAdminAuth_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_hasAdminAuth_exception() override incorrect."); }

        virtual void callback_hasDevAuth(tars::Int32 ret, tars::Bool has)
        { throw std::runtime_error("callback_hasDevAuth() override incorrect."); }
        virtual void callback_hasDevAuth_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_hasDevAuth_exception() override incorrect."); }

        virtual void callback_hasOpeAuth(tars::Int32 ret, tars::Bool has)
        { throw std::runtime_error("callback_hasOpeAuth() override incorrect."); }
        virtual void callback_hasOpeAuth_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_hasOpeAuth_exception() override incorrect."); }

        virtual void callback_hasServer(tars::Int32 ret, tars::Bool has)
        { throw std::runtime_error("callback_hasServer() override incorrect."); }
        virtual void callback_hasServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_hasServer_exception() override incorrect."); }

        virtual void callback_insertAdapterConf(tars::Int32 ret)
        { throw std::runtime_error("callback_insertAdapterConf() override incorrect."); }
        virtual void callback_insertAdapterConf_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_insertAdapterConf_exception() override incorrect."); }

        virtual void callback_insertConfigFile(tars::Int32 ret)
        { throw std::runtime_error("callback_insertConfigFile() override incorrect."); }
        virtual void callback_insertConfigFile_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_insertConfigFile_exception() override incorrect."); }

        virtual void callback_insertHistoryConfigFile(tars::Int32 ret)
        { throw std::runtime_error("callback_insertHistoryConfigFile() override incorrect."); }
        virtual void callback_insertHistoryConfigFile_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_insertHistoryConfigFile_exception() override incorrect."); }

        virtual void callback_insertServerConf(tars::Int32 ret)
        { throw std::runtime_error("callback_insertServerConf() override incorrect."); }
        virtual void callback_insertServerConf_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_insertServerConf_exception() override incorrect."); }

        virtual void callback_loadServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_loadServer() override incorrect."); }
        virtual void callback_loadServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_loadServer_exception() override incorrect."); }
        virtual void callback_loadServer(tars::Int32 ret, std::string&&  result)
        { callback_loadServer(ret, result); }

        virtual void callback_notifyServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_notifyServer() override incorrect."); }
        virtual void callback_notifyServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_notifyServer_exception() override incorrect."); }
        virtual void callback_notifyServer(tars::Int32 ret, std::string&&  result)
        { callback_notifyServer(ret, result); }

        virtual void callback_pingNode(tars::Bool ret,  const std::string& result)
        { throw std::runtime_error("callback_pingNode() override incorrect."); }
        virtual void callback_pingNode_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_pingNode_exception() override incorrect."); }
        virtual void callback_pingNode(tars::Bool ret, std::string&&  result)
        { callback_pingNode(ret, result); }

        virtual void callback_registerPlugin(tars::Int32 ret)
        { throw std::runtime_error("callback_registerPlugin() override incorrect."); }
        virtual void callback_registerPlugin_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_registerPlugin_exception() override incorrect."); }

        virtual void callback_reportNode(tars::Int32 ret)
        { throw std::runtime_error("callback_reportNode() override incorrect."); }
        virtual void callback_reportNode_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_reportNode_exception() override incorrect."); }

        virtual void callback_reportResult(tars::Int32 ret)
        { throw std::runtime_error("callback_reportResult() override incorrect."); }
        virtual void callback_reportResult_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_reportResult_exception() override incorrect."); }

        virtual void callback_restartServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_restartServer() override incorrect."); }
        virtual void callback_restartServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_restartServer_exception() override incorrect."); }
        virtual void callback_restartServer(tars::Int32 ret, std::string&&  result)
        { callback_restartServer(ret, result); }

        virtual void callback_setTaskItemInfo(tars::Int32 ret)
        { throw std::runtime_error("callback_setTaskItemInfo() override incorrect."); }
        virtual void callback_setTaskItemInfo_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_setTaskItemInfo_exception() override incorrect."); }

        virtual void callback_shutdownNode(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_shutdownNode() override incorrect."); }
        virtual void callback_shutdownNode_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_shutdownNode_exception() override incorrect."); }
        virtual void callback_shutdownNode(tars::Int32 ret, std::string&&  result)
        { callback_shutdownNode(ret, result); }

        virtual void callback_startServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_startServer() override incorrect."); }
        virtual void callback_startServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_startServer_exception() override incorrect."); }
        virtual void callback_startServer(tars::Int32 ret, std::string&&  result)
        { callback_startServer(ret, result); }

        virtual void callback_stopServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_stopServer() override incorrect."); }
        virtual void callback_stopServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_stopServer_exception() override incorrect."); }
        virtual void callback_stopServer(tars::Int32 ret, std::string&&  result)
        { callback_stopServer(ret, result); }

        virtual void callback_undeploy(tars::Int32 ret,  const std::string& log)
        { throw std::runtime_error("callback_undeploy() override incorrect."); }
        virtual void callback_undeploy_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_undeploy_exception() override incorrect."); }
        virtual void callback_undeploy(tars::Int32 ret, std::string&&  log)
        { callback_undeploy(ret, log); }

        virtual void callback_uninstallServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_uninstallServer() override incorrect."); }
        virtual void callback_uninstallServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_uninstallServer_exception() override incorrect."); }
        virtual void callback_uninstallServer(tars::Int32 ret, std::string&&  result)
        { callback_uninstallServer(ret, result); }

        virtual void callback_updatePatchLog(tars::Int32 ret)
        { throw std::runtime_error("callback_updatePatchLog() override incorrect."); }
        virtual void callback_updatePatchLog_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_updatePatchLog_exception() override incorrect."); }

        virtual void callback_updateServerFlowState(tars::Int32 ret)
        { throw std::runtime_error("callback_updateServerFlowState() override incorrect."); }
        virtual void callback_updateServerFlowState_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_updateServerFlowState_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "checkDockerRegistry",
                "checkServer",
                "checkTicket",
                "delCache",
                "deleteNode",
                "deletePatchFile",
                "destroyServer",
                "dockerPull",
                "forceDockerLogin",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getConfigFileId",
                "getGroupId",
                "getLogData",
                "getLogFileList",
                "getNodeList",
                "getNodeLoad",
                "getNodeVesion",
                "getPatchPackage",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerNameList",
                "getServerProfileTemplate",
                "getServerState",
                "getServerTree",
                "getServers",
                "getTaskHistory",
                "getTaskRsp",
                "getVersion",
                "hasAdminAuth",
                "hasDevAuth",
                "hasOpeAuth",
                "hasServer",
                "insertAdapterConf",
                "insertConfigFile",
                "insertHistoryConfigFile",
                "insertServerConf",
                "loadServer",
                "notifyServer",
                "pingNode",
                "registerPlugin",
                "reportNode",
                "reportResult",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "uninstallServer",
                "updatePatchLog",
                "updateServerFlowState"
            };
            auto it = _msg_->response->status.find("TARS_FUNC");
            pair<string*, string*> r = equal_range(__AdminReg_all, __AdminReg_all+56, (it==_msg_->response->status.end())?_msg_->request.sFuncName:it->second);
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __AdminReg_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_addTaskReq_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_addTaskReq(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_batchPatch_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_batchPatch(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_checkDockerRegistry_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_checkDockerRegistry(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_checkServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_checkServer(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_checkTicket_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string uid;
                    _is.read(uid, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_checkTicket(_ret, std::move(uid));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_delCache(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_deleteNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_deleteNode(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_deletePatchFile_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_deletePatchFile(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_destroyServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_dockerPull_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_dockerPull(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<std::string> result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_forceDockerLogin(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllApplicationNames_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    vector<std::string> _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getAllApplicationNames(std::move(_ret), std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllNodeNames_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    vector<std::string> _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getAllNodeNames(std::move(_ret), std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllServerIds_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    vector<vector<std::string> > _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getAllServerIds(std::move(_ret), std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getClientIp_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string sClientIp;
                    _is.read(sClientIp, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getClientIp(_ret, std::move(sClientIp));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getConfigFileId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Int32 configId;
                    _is.read(configId, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getConfigFileId(_ret, configId);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getGroupId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Int32 groupId;
                    _is.read(groupId, 2, true);
                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getGroupId(_ret, groupId, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogData_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string fileData;
                    _is.read(fileData, 6, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getLogData(_ret, std::move(fileData));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<std::string> logFileList;
                    _is.read(logFileList, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getLogFileList(_ret, std::move(logFileList));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    map<std::string, std::string> heartbeats;
                    _is.read(heartbeats, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getNodeList(_ret, std::move(heartbeats));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string fileData;
                    _is.read(fileData, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getNodeLoad(_ret, std::move(fileData));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 21:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeVesion_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string version;
                    _is.read(version, 2, true);
                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getNodeVesion(_ret, std::move(version), std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 22:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPackage_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::PatchPackage pack;
                    _is.read(pack, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getPatchPackage(_ret, std::move(pack));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 23:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::PatchInfo tPatchInfo;
                    _is.read(tPatchInfo, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getPatchPercent(_ret, std::move(tPatchInfo));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 24:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getProfileTemplate_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string profileTemplate;
                    _is.read(profileTemplate, 2, true);
                    std::string resultDesc;
                    _is.read(resultDesc, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getProfileTemplate(_ret, std::move(profileTemplate), std::move(resultDesc));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 25:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerNameList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<map<std::string, std::string> > serverList;
                    _is.read(serverList, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getServerNameList(_ret, std::move(serverList));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 26:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerProfileTemplate_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string profileTemplate;
                    _is.read(profileTemplate, 4, true);
                    std::string resultDesc;
                    _is.read(resultDesc, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getServerProfileTemplate(_ret, std::move(profileTemplate), std::move(resultDesc));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 27:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerState_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::ServerStateDesc state;
                    _is.read(state, 4, true);
                    std::string result;
                    _is.read(result, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getServerState(_ret, std::move(state), std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 28:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerTree_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::ServerTree> tree;
                    _is.read(tree, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getServerTree(_ret, std::move(tree));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 29:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServers_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::FrameworkServer> servers;
                    _is.read(servers, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getServers(_ret, std::move(servers));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 30:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskHistory_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::TaskRsp> taskRsps;
                    _is.read(taskRsps, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getTaskHistory(_ret, std::move(taskRsps));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 31:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskRsp_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::TaskRsp taskRsp;
                    _is.read(taskRsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getTaskRsp(_ret, std::move(taskRsp));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 32:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getVersion_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string version;
                    _is.read(version, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getVersion(_ret, std::move(version));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 33:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasAdminAuth_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Bool has = false;
                    _is.read(has, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_hasAdminAuth(_ret, has);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 34:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasDevAuth_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Bool has = false;
                    _is.read(has, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_hasDevAuth(_ret, has);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 35:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasOpeAuth_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Bool has = false;
                    _is.read(has, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_hasOpeAuth(_ret, has);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 36:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Bool has = false;
                    _is.read(has, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_hasServer(_ret, has);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 37:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertAdapterConf_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_insertAdapterConf(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 38:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertConfigFile_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_insertConfigFile(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 39:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertHistoryConfigFile_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_insertHistoryConfigFile(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 40:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertServerConf_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_insertServerConf(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 41:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_loadServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 42:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_notifyServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 43:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_pingNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_pingNode(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 44:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_registerPlugin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_registerPlugin(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 45:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_reportNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_reportNode(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 46:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_reportResult_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_reportResult(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 47:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_restartServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_restartServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 48:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_setTaskItemInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_setTaskItemInfo(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 49:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdownNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_shutdownNode(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 50:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_startServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 51:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_stopServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 52:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_undeploy_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string log;
                    _is.read(log, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_undeploy(_ret, std::move(log));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 53:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_uninstallServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_uninstallServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 54:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updatePatchLog_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_updatePatchLog(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 55:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updateServerFlowState_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_updateServerFlowState(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<AdminRegPrxCallback> AdminRegPrxCallbackPtr;

    //callback of promise async proxy for client
    class AdminRegPrxCallbackPromise: public tars::ServantProxyCallback
    {
    public:
        virtual ~AdminRegPrxCallbackPromise(){}
    public:
        struct PromiseaddTaskReq: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseaddTaskReq > PromiseaddTaskReqPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > &promise)
        : _promise_addTaskReq(promise)
        {}
        
        virtual void callback_addTaskReq(const AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr &ptr)
        {
            _promise_addTaskReq.setValue(ptr);
        }
        virtual void callback_addTaskReq_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:addTaskReq_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_addTaskReq.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > _promise_addTaskReq;

    public:
        struct PromisebatchPatch: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisebatchPatch > PromisebatchPatchPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > &promise)
        : _promise_batchPatch(promise)
        {}
        
        virtual void callback_batchPatch(const AdminRegPrxCallbackPromise::PromisebatchPatchPtr &ptr)
        {
            _promise_batchPatch.setValue(ptr);
        }
        virtual void callback_batchPatch_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:batchPatch_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_batchPatch.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > _promise_batchPatch;

    public:
        struct PromisecheckDockerRegistry: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisecheckDockerRegistry > PromisecheckDockerRegistryPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr > &promise)
        : _promise_checkDockerRegistry(promise)
        {}
        
        virtual void callback_checkDockerRegistry(const AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr &ptr)
        {
            _promise_checkDockerRegistry.setValue(ptr);
        }
        virtual void callback_checkDockerRegistry_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:checkDockerRegistry_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_checkDockerRegistry.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr > _promise_checkDockerRegistry;

    public:
        struct PromisecheckServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisecheckServer > PromisecheckServerPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisecheckServerPtr > &promise)
        : _promise_checkServer(promise)
        {}
        
        virtual void callback_checkServer(const AdminRegPrxCallbackPromise::PromisecheckServerPtr &ptr)
        {
            _promise_checkServer.setValue(ptr);
        }
        virtual void callback_checkServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:checkServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_checkServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisecheckServerPtr > _promise_checkServer;

    public:
        struct PromisecheckTicket: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string uid;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisecheckTicket > PromisecheckTicketPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisecheckTicketPtr > &promise)
        : _promise_checkTicket(promise)
        {}
        
        virtual void callback_checkTicket(const AdminRegPrxCallbackPromise::PromisecheckTicketPtr &ptr)
        {
            _promise_checkTicket.setValue(ptr);
        }
        virtual void callback_checkTicket_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:checkTicket_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_checkTicket.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisecheckTicketPtr > _promise_checkTicket;

    public:
        struct PromisedelCache: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisedelCache > PromisedelCachePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisedelCachePtr > &promise)
        : _promise_delCache(promise)
        {}
        
        virtual void callback_delCache(const AdminRegPrxCallbackPromise::PromisedelCachePtr &ptr)
        {
            _promise_delCache.setValue(ptr);
        }
        virtual void callback_delCache_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:delCache_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_delCache.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisedelCachePtr > _promise_delCache;

    public:
        struct PromisedeleteNode: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisedeleteNode > PromisedeleteNodePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisedeleteNodePtr > &promise)
        : _promise_deleteNode(promise)
        {}
        
        virtual void callback_deleteNode(const AdminRegPrxCallbackPromise::PromisedeleteNodePtr &ptr)
        {
            _promise_deleteNode.setValue(ptr);
        }
        virtual void callback_deleteNode_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:deleteNode_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_deleteNode.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisedeleteNodePtr > _promise_deleteNode;

    public:
        struct PromisedeletePatchFile: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisedeletePatchFile > PromisedeletePatchFilePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr > &promise)
        : _promise_deletePatchFile(promise)
        {}
        
        virtual void callback_deletePatchFile(const AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr &ptr)
        {
            _promise_deletePatchFile.setValue(ptr);
        }
        virtual void callback_deletePatchFile_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:deletePatchFile_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_deletePatchFile.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr > _promise_deletePatchFile;

    public:
        struct PromisedestroyServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisedestroyServer > PromisedestroyServerPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisedestroyServerPtr > &promise)
        : _promise_destroyServer(promise)
        {}
        
        virtual void callback_destroyServer(const AdminRegPrxCallbackPromise::PromisedestroyServerPtr &ptr)
        {
            _promise_destroyServer.setValue(ptr);
        }
        virtual void callback_destroyServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:destroyServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_destroyServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisedestroyServerPtr > _promise_destroyServer;

    public:
        struct PromisedockerPull: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisedockerPull > PromisedockerPullPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisedockerPullPtr > &promise)
        : _promise_dockerPull(promise)
        {}
        
        virtual void callback_dockerPull(const AdminRegPrxCallbackPromise::PromisedockerPullPtr &ptr)
        {
            _promise_dockerPull.setValue(ptr);
        }
        virtual void callback_dockerPull_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:dockerPull_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_dockerPull.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisedockerPullPtr > _promise_dockerPull;

    public:
        struct PromiseforceDockerLogin: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<std::string> result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseforceDockerLogin > PromiseforceDockerLoginPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr > &promise)
        : _promise_forceDockerLogin(promise)
        {}
        
        virtual void callback_forceDockerLogin(const AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr &ptr)
        {
            _promise_forceDockerLogin.setValue(ptr);
        }
        virtual void callback_forceDockerLogin_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:forceDockerLogin_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_forceDockerLogin.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr > _promise_forceDockerLogin;

    public:
        struct PromisegetAllApplicationNames: virtual public TC_HandleBase
        {
        public:
            vector<std::string> _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetAllApplicationNames > PromisegetAllApplicationNamesPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > &promise)
        : _promise_getAllApplicationNames(promise)
        {}
        
        virtual void callback_getAllApplicationNames(const AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr &ptr)
        {
            _promise_getAllApplicationNames.setValue(ptr);
        }
        virtual void callback_getAllApplicationNames_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getAllApplicationNames_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getAllApplicationNames.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > _promise_getAllApplicationNames;

    public:
        struct PromisegetAllNodeNames: virtual public TC_HandleBase
        {
        public:
            vector<std::string> _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetAllNodeNames > PromisegetAllNodeNamesPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > &promise)
        : _promise_getAllNodeNames(promise)
        {}
        
        virtual void callback_getAllNodeNames(const AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr &ptr)
        {
            _promise_getAllNodeNames.setValue(ptr);
        }
        virtual void callback_getAllNodeNames_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getAllNodeNames_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getAllNodeNames.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > _promise_getAllNodeNames;

    public:
        struct PromisegetAllServerIds: virtual public TC_HandleBase
        {
        public:
            vector<vector<std::string> > _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetAllServerIds > PromisegetAllServerIdsPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > &promise)
        : _promise_getAllServerIds(promise)
        {}
        
        virtual void callback_getAllServerIds(const AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr &ptr)
        {
            _promise_getAllServerIds.setValue(ptr);
        }
        virtual void callback_getAllServerIds_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getAllServerIds_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getAllServerIds.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > _promise_getAllServerIds;

    public:
        struct PromisegetClientIp: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string sClientIp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetClientIp > PromisegetClientIpPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > &promise)
        : _promise_getClientIp(promise)
        {}
        
        virtual void callback_getClientIp(const AdminRegPrxCallbackPromise::PromisegetClientIpPtr &ptr)
        {
            _promise_getClientIp.setValue(ptr);
        }
        virtual void callback_getClientIp_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getClientIp_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getClientIp.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > _promise_getClientIp;

    public:
        struct PromisegetConfigFileId: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Int32 configId;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetConfigFileId > PromisegetConfigFileIdPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetConfigFileIdPtr > &promise)
        : _promise_getConfigFileId(promise)
        {}
        
        virtual void callback_getConfigFileId(const AdminRegPrxCallbackPromise::PromisegetConfigFileIdPtr &ptr)
        {
            _promise_getConfigFileId.setValue(ptr);
        }
        virtual void callback_getConfigFileId_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getConfigFileId_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getConfigFileId.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetConfigFileIdPtr > _promise_getConfigFileId;

    public:
        struct PromisegetGroupId: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Int32 groupId;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetGroupId > PromisegetGroupIdPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > &promise)
        : _promise_getGroupId(promise)
        {}
        
        virtual void callback_getGroupId(const AdminRegPrxCallbackPromise::PromisegetGroupIdPtr &ptr)
        {
            _promise_getGroupId.setValue(ptr);
        }
        virtual void callback_getGroupId_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getGroupId_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getGroupId.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > _promise_getGroupId;

    public:
        struct PromisegetLogData: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string fileData;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetLogData > PromisegetLogDataPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetLogDataPtr > &promise)
        : _promise_getLogData(promise)
        {}
        
        virtual void callback_getLogData(const AdminRegPrxCallbackPromise::PromisegetLogDataPtr &ptr)
        {
            _promise_getLogData.setValue(ptr);
        }
        virtual void callback_getLogData_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getLogData_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getLogData.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetLogDataPtr > _promise_getLogData;

    public:
        struct PromisegetLogFileList: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<std::string> logFileList;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetLogFileList > PromisegetLogFileListPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetLogFileListPtr > &promise)
        : _promise_getLogFileList(promise)
        {}
        
        virtual void callback_getLogFileList(const AdminRegPrxCallbackPromise::PromisegetLogFileListPtr &ptr)
        {
            _promise_getLogFileList.setValue(ptr);
        }
        virtual void callback_getLogFileList_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getLogFileList_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getLogFileList.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetLogFileListPtr > _promise_getLogFileList;

    public:
        struct PromisegetNodeList: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> heartbeats;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetNodeList > PromisegetNodeListPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetNodeListPtr > &promise)
        : _promise_getNodeList(promise)
        {}
        
        virtual void callback_getNodeList(const AdminRegPrxCallbackPromise::PromisegetNodeListPtr &ptr)
        {
            _promise_getNodeList.setValue(ptr);
        }
        virtual void callback_getNodeList_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getNodeList_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getNodeList.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetNodeListPtr > _promise_getNodeList;

    public:
        struct PromisegetNodeLoad: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string fileData;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetNodeLoad > PromisegetNodeLoadPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr > &promise)
        : _promise_getNodeLoad(promise)
        {}
        
        virtual void callback_getNodeLoad(const AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr &ptr)
        {
            _promise_getNodeLoad.setValue(ptr);
        }
        virtual void callback_getNodeLoad_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getNodeLoad_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getNodeLoad.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr > _promise_getNodeLoad;

    public:
        struct PromisegetNodeVesion: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string version;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetNodeVesion > PromisegetNodeVesionPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > &promise)
        : _promise_getNodeVesion(promise)
        {}
        
        virtual void callback_getNodeVesion(const AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr &ptr)
        {
            _promise_getNodeVesion.setValue(ptr);
        }
        virtual void callback_getNodeVesion_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getNodeVesion_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getNodeVesion.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > _promise_getNodeVesion;

    public:
        struct PromisegetPatchPackage: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::PatchPackage pack;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetPatchPackage > PromisegetPatchPackagePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPackagePtr > &promise)
        : _promise_getPatchPackage(promise)
        {}
        
        virtual void callback_getPatchPackage(const AdminRegPrxCallbackPromise::PromisegetPatchPackagePtr &ptr)
        {
            _promise_getPatchPackage.setValue(ptr);
        }
        virtual void callback_getPatchPackage_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getPatchPackage_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getPatchPackage.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPackagePtr > _promise_getPatchPackage;

    public:
        struct PromisegetPatchPercent: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::PatchInfo tPatchInfo;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetPatchPercent > PromisegetPatchPercentPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > &promise)
        : _promise_getPatchPercent(promise)
        {}
        
        virtual void callback_getPatchPercent(const AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr &ptr)
        {
            _promise_getPatchPercent.setValue(ptr);
        }
        virtual void callback_getPatchPercent_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getPatchPercent_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getPatchPercent.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > _promise_getPatchPercent;

    public:
        struct PromisegetProfileTemplate: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string profileTemplate;
            std::string resultDesc;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetProfileTemplate > PromisegetProfileTemplatePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > &promise)
        : _promise_getProfileTemplate(promise)
        {}
        
        virtual void callback_getProfileTemplate(const AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr &ptr)
        {
            _promise_getProfileTemplate.setValue(ptr);
        }
        virtual void callback_getProfileTemplate_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getProfileTemplate_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getProfileTemplate.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > _promise_getProfileTemplate;

    public:
        struct PromisegetServerNameList: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<map<std::string, std::string> > serverList;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetServerNameList > PromisegetServerNameListPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerNameListPtr > &promise)
        : _promise_getServerNameList(promise)
        {}
        
        virtual void callback_getServerNameList(const AdminRegPrxCallbackPromise::PromisegetServerNameListPtr &ptr)
        {
            _promise_getServerNameList.setValue(ptr);
        }
        virtual void callback_getServerNameList_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getServerNameList_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getServerNameList.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerNameListPtr > _promise_getServerNameList;

    public:
        struct PromisegetServerProfileTemplate: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string profileTemplate;
            std::string resultDesc;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplate > PromisegetServerProfileTemplatePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > &promise)
        : _promise_getServerProfileTemplate(promise)
        {}
        
        virtual void callback_getServerProfileTemplate(const AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr &ptr)
        {
            _promise_getServerProfileTemplate.setValue(ptr);
        }
        virtual void callback_getServerProfileTemplate_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getServerProfileTemplate_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getServerProfileTemplate.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > _promise_getServerProfileTemplate;

    public:
        struct PromisegetServerState: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::ServerStateDesc state;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetServerState > PromisegetServerStatePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > &promise)
        : _promise_getServerState(promise)
        {}
        
        virtual void callback_getServerState(const AdminRegPrxCallbackPromise::PromisegetServerStatePtr &ptr)
        {
            _promise_getServerState.setValue(ptr);
        }
        virtual void callback_getServerState_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getServerState_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getServerState.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > _promise_getServerState;

    public:
        struct PromisegetServerTree: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::ServerTree> tree;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetServerTree > PromisegetServerTreePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerTreePtr > &promise)
        : _promise_getServerTree(promise)
        {}
        
        virtual void callback_getServerTree(const AdminRegPrxCallbackPromise::PromisegetServerTreePtr &ptr)
        {
            _promise_getServerTree.setValue(ptr);
        }
        virtual void callback_getServerTree_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getServerTree_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getServerTree.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerTreePtr > _promise_getServerTree;

    public:
        struct PromisegetServers: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::FrameworkServer> servers;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetServers > PromisegetServersPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetServersPtr > &promise)
        : _promise_getServers(promise)
        {}
        
        virtual void callback_getServers(const AdminRegPrxCallbackPromise::PromisegetServersPtr &ptr)
        {
            _promise_getServers.setValue(ptr);
        }
        virtual void callback_getServers_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getServers_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getServers.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetServersPtr > _promise_getServers;

    public:
        struct PromisegetTaskHistory: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::TaskRsp> taskRsps;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetTaskHistory > PromisegetTaskHistoryPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > &promise)
        : _promise_getTaskHistory(promise)
        {}
        
        virtual void callback_getTaskHistory(const AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr &ptr)
        {
            _promise_getTaskHistory.setValue(ptr);
        }
        virtual void callback_getTaskHistory_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getTaskHistory_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getTaskHistory.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > _promise_getTaskHistory;

    public:
        struct PromisegetTaskRsp: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::TaskRsp taskRsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetTaskRsp > PromisegetTaskRspPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > &promise)
        : _promise_getTaskRsp(promise)
        {}
        
        virtual void callback_getTaskRsp(const AdminRegPrxCallbackPromise::PromisegetTaskRspPtr &ptr)
        {
            _promise_getTaskRsp.setValue(ptr);
        }
        virtual void callback_getTaskRsp_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getTaskRsp_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getTaskRsp.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > _promise_getTaskRsp;

    public:
        struct PromisegetVersion: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string version;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetVersion > PromisegetVersionPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisegetVersionPtr > &promise)
        : _promise_getVersion(promise)
        {}
        
        virtual void callback_getVersion(const AdminRegPrxCallbackPromise::PromisegetVersionPtr &ptr)
        {
            _promise_getVersion.setValue(ptr);
        }
        virtual void callback_getVersion_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getVersion_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getVersion.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisegetVersionPtr > _promise_getVersion;

    public:
        struct PromisehasAdminAuth: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Bool has;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisehasAdminAuth > PromisehasAdminAuthPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisehasAdminAuthPtr > &promise)
        : _promise_hasAdminAuth(promise)
        {}
        
        virtual void callback_hasAdminAuth(const AdminRegPrxCallbackPromise::PromisehasAdminAuthPtr &ptr)
        {
            _promise_hasAdminAuth.setValue(ptr);
        }
        virtual void callback_hasAdminAuth_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:hasAdminAuth_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_hasAdminAuth.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisehasAdminAuthPtr > _promise_hasAdminAuth;

    public:
        struct PromisehasDevAuth: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Bool has;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisehasDevAuth > PromisehasDevAuthPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisehasDevAuthPtr > &promise)
        : _promise_hasDevAuth(promise)
        {}
        
        virtual void callback_hasDevAuth(const AdminRegPrxCallbackPromise::PromisehasDevAuthPtr &ptr)
        {
            _promise_hasDevAuth.setValue(ptr);
        }
        virtual void callback_hasDevAuth_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:hasDevAuth_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_hasDevAuth.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisehasDevAuthPtr > _promise_hasDevAuth;

    public:
        struct PromisehasOpeAuth: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Bool has;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisehasOpeAuth > PromisehasOpeAuthPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisehasOpeAuthPtr > &promise)
        : _promise_hasOpeAuth(promise)
        {}
        
        virtual void callback_hasOpeAuth(const AdminRegPrxCallbackPromise::PromisehasOpeAuthPtr &ptr)
        {
            _promise_hasOpeAuth.setValue(ptr);
        }
        virtual void callback_hasOpeAuth_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:hasOpeAuth_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_hasOpeAuth.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisehasOpeAuthPtr > _promise_hasOpeAuth;

    public:
        struct PromisehasServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Bool has;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisehasServer > PromisehasServerPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisehasServerPtr > &promise)
        : _promise_hasServer(promise)
        {}
        
        virtual void callback_hasServer(const AdminRegPrxCallbackPromise::PromisehasServerPtr &ptr)
        {
            _promise_hasServer.setValue(ptr);
        }
        virtual void callback_hasServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:hasServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_hasServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisehasServerPtr > _promise_hasServer;

    public:
        struct PromiseinsertAdapterConf: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseinsertAdapterConf > PromiseinsertAdapterConfPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertAdapterConfPtr > &promise)
        : _promise_insertAdapterConf(promise)
        {}
        
        virtual void callback_insertAdapterConf(const AdminRegPrxCallbackPromise::PromiseinsertAdapterConfPtr &ptr)
        {
            _promise_insertAdapterConf.setValue(ptr);
        }
        virtual void callback_insertAdapterConf_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:insertAdapterConf_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_insertAdapterConf.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertAdapterConfPtr > _promise_insertAdapterConf;

    public:
        struct PromiseinsertConfigFile: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseinsertConfigFile > PromiseinsertConfigFilePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertConfigFilePtr > &promise)
        : _promise_insertConfigFile(promise)
        {}
        
        virtual void callback_insertConfigFile(const AdminRegPrxCallbackPromise::PromiseinsertConfigFilePtr &ptr)
        {
            _promise_insertConfigFile.setValue(ptr);
        }
        virtual void callback_insertConfigFile_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:insertConfigFile_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_insertConfigFile.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertConfigFilePtr > _promise_insertConfigFile;

    public:
        struct PromiseinsertHistoryConfigFile: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseinsertHistoryConfigFile > PromiseinsertHistoryConfigFilePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertHistoryConfigFilePtr > &promise)
        : _promise_insertHistoryConfigFile(promise)
        {}
        
        virtual void callback_insertHistoryConfigFile(const AdminRegPrxCallbackPromise::PromiseinsertHistoryConfigFilePtr &ptr)
        {
            _promise_insertHistoryConfigFile.setValue(ptr);
        }
        virtual void callback_insertHistoryConfigFile_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:insertHistoryConfigFile_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_insertHistoryConfigFile.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertHistoryConfigFilePtr > _promise_insertHistoryConfigFile;

    public:
        struct PromiseinsertServerConf: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseinsertServerConf > PromiseinsertServerConfPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertServerConfPtr > &promise)
        : _promise_insertServerConf(promise)
        {}
        
        virtual void callback_insertServerConf(const AdminRegPrxCallbackPromise::PromiseinsertServerConfPtr &ptr)
        {
            _promise_insertServerConf.setValue(ptr);
        }
        virtual void callback_insertServerConf_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:insertServerConf_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_insertServerConf.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertServerConfPtr > _promise_insertServerConf;

    public:
        struct PromiseloadServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseloadServer > PromiseloadServerPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseloadServerPtr > &promise)
        : _promise_loadServer(promise)
        {}
        
        virtual void callback_loadServer(const AdminRegPrxCallbackPromise::PromiseloadServerPtr &ptr)
        {
            _promise_loadServer.setValue(ptr);
        }
        virtual void callback_loadServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:loadServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_loadServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseloadServerPtr > _promise_loadServer;

    public:
        struct PromisenotifyServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisenotifyServer > PromisenotifyServerPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > &promise)
        : _promise_notifyServer(promise)
        {}
        
        virtual void callback_notifyServer(const AdminRegPrxCallbackPromise::PromisenotifyServerPtr &ptr)
        {
            _promise_notifyServer.setValue(ptr);
        }
        virtual void callback_notifyServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:notifyServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_notifyServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > _promise_notifyServer;

    public:
        struct PromisepingNode: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisepingNode > PromisepingNodePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisepingNodePtr > &promise)
        : _promise_pingNode(promise)
        {}
        
        virtual void callback_pingNode(const AdminRegPrxCallbackPromise::PromisepingNodePtr &ptr)
        {
            _promise_pingNode.setValue(ptr);
        }
        virtual void callback_pingNode_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:pingNode_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_pingNode.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisepingNodePtr > _promise_pingNode;

    public:
        struct PromiseregisterPlugin: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseregisterPlugin > PromiseregisterPluginPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseregisterPluginPtr > &promise)
        : _promise_registerPlugin(promise)
        {}
        
        virtual void callback_registerPlugin(const AdminRegPrxCallbackPromise::PromiseregisterPluginPtr &ptr)
        {
            _promise_registerPlugin.setValue(ptr);
        }
        virtual void callback_registerPlugin_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:registerPlugin_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_registerPlugin.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseregisterPluginPtr > _promise_registerPlugin;

    public:
        struct PromisereportNode: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisereportNode > PromisereportNodePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisereportNodePtr > &promise)
        : _promise_reportNode(promise)
        {}
        
        virtual void callback_reportNode(const AdminRegPrxCallbackPromise::PromisereportNodePtr &ptr)
        {
            _promise_reportNode.setValue(ptr);
        }
        virtual void callback_reportNode_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:reportNode_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_reportNode.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisereportNodePtr > _promise_reportNode;

    public:
        struct PromisereportResult: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisereportResult > PromisereportResultPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisereportResultPtr > &promise)
        : _promise_reportResult(promise)
        {}
        
        virtual void callback_reportResult(const AdminRegPrxCallbackPromise::PromisereportResultPtr &ptr)
        {
            _promise_reportResult.setValue(ptr);
        }
        virtual void callback_reportResult_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:reportResult_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_reportResult.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisereportResultPtr > _promise_reportResult;

    public:
        struct PromiserestartServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiserestartServer > PromiserestartServerPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiserestartServerPtr > &promise)
        : _promise_restartServer(promise)
        {}
        
        virtual void callback_restartServer(const AdminRegPrxCallbackPromise::PromiserestartServerPtr &ptr)
        {
            _promise_restartServer.setValue(ptr);
        }
        virtual void callback_restartServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:restartServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_restartServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiserestartServerPtr > _promise_restartServer;

    public:
        struct PromisesetTaskItemInfo: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisesetTaskItemInfo > PromisesetTaskItemInfoPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > &promise)
        : _promise_setTaskItemInfo(promise)
        {}
        
        virtual void callback_setTaskItemInfo(const AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr &ptr)
        {
            _promise_setTaskItemInfo.setValue(ptr);
        }
        virtual void callback_setTaskItemInfo_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:setTaskItemInfo_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_setTaskItemInfo.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > _promise_setTaskItemInfo;

    public:
        struct PromiseshutdownNode: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseshutdownNode > PromiseshutdownNodePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > &promise)
        : _promise_shutdownNode(promise)
        {}
        
        virtual void callback_shutdownNode(const AdminRegPrxCallbackPromise::PromiseshutdownNodePtr &ptr)
        {
            _promise_shutdownNode.setValue(ptr);
        }
        virtual void callback_shutdownNode_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:shutdownNode_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_shutdownNode.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > _promise_shutdownNode;

    public:
        struct PromisestartServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisestartServer > PromisestartServerPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisestartServerPtr > &promise)
        : _promise_startServer(promise)
        {}
        
        virtual void callback_startServer(const AdminRegPrxCallbackPromise::PromisestartServerPtr &ptr)
        {
            _promise_startServer.setValue(ptr);
        }
        virtual void callback_startServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:startServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_startServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisestartServerPtr > _promise_startServer;

    public:
        struct PromisestopServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisestopServer > PromisestopServerPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromisestopServerPtr > &promise)
        : _promise_stopServer(promise)
        {}
        
        virtual void callback_stopServer(const AdminRegPrxCallbackPromise::PromisestopServerPtr &ptr)
        {
            _promise_stopServer.setValue(ptr);
        }
        virtual void callback_stopServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:stopServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_stopServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromisestopServerPtr > _promise_stopServer;

    public:
        struct Promiseundeploy: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string log;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::Promiseundeploy > PromiseundeployPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseundeployPtr > &promise)
        : _promise_undeploy(promise)
        {}
        
        virtual void callback_undeploy(const AdminRegPrxCallbackPromise::PromiseundeployPtr &ptr)
        {
            _promise_undeploy.setValue(ptr);
        }
        virtual void callback_undeploy_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:undeploy_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_undeploy.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseundeployPtr > _promise_undeploy;

    public:
        struct PromiseuninstallServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseuninstallServer > PromiseuninstallServerPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseuninstallServerPtr > &promise)
        : _promise_uninstallServer(promise)
        {}
        
        virtual void callback_uninstallServer(const AdminRegPrxCallbackPromise::PromiseuninstallServerPtr &ptr)
        {
            _promise_uninstallServer.setValue(ptr);
        }
        virtual void callback_uninstallServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:uninstallServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_uninstallServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseuninstallServerPtr > _promise_uninstallServer;

    public:
        struct PromiseupdatePatchLog: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseupdatePatchLog > PromiseupdatePatchLogPtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > &promise)
        : _promise_updatePatchLog(promise)
        {}
        
        virtual void callback_updatePatchLog(const AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr &ptr)
        {
            _promise_updatePatchLog.setValue(ptr);
        }
        virtual void callback_updatePatchLog_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:updatePatchLog_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_updatePatchLog.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > _promise_updatePatchLog;

    public:
        struct PromiseupdateServerFlowState: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseupdateServerFlowState > PromiseupdateServerFlowStatePtr;

        AdminRegPrxCallbackPromise(const tars::Promise< AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr > &promise)
        : _promise_updateServerFlowState(promise)
        {}
        
        virtual void callback_updateServerFlowState(const AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr &ptr)
        {
            _promise_updateServerFlowState.setValue(ptr);
        }
        virtual void callback_updateServerFlowState_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:updateServerFlowState_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_updateServerFlowState.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr > _promise_updateServerFlowState;

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "checkDockerRegistry",
                "checkServer",
                "checkTicket",
                "delCache",
                "deleteNode",
                "deletePatchFile",
                "destroyServer",
                "dockerPull",
                "forceDockerLogin",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getConfigFileId",
                "getGroupId",
                "getLogData",
                "getLogFileList",
                "getNodeList",
                "getNodeLoad",
                "getNodeVesion",
                "getPatchPackage",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerNameList",
                "getServerProfileTemplate",
                "getServerState",
                "getServerTree",
                "getServers",
                "getTaskHistory",
                "getTaskRsp",
                "getVersion",
                "hasAdminAuth",
                "hasDevAuth",
                "hasOpeAuth",
                "hasServer",
                "insertAdapterConf",
                "insertConfigFile",
                "insertHistoryConfigFile",
                "insertServerConf",
                "loadServer",
                "notifyServer",
                "pingNode",
                "registerPlugin",
                "reportNode",
                "reportResult",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "uninstallServer",
                "updatePatchLog",
                "updateServerFlowState"
            };

            pair<string*, string*> r = equal_range(__AdminReg_all, __AdminReg_all+56, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __AdminReg_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_addTaskReq_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr ptr = new AdminRegPrxCallbackPromise::PromiseaddTaskReq();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_addTaskReq_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_addTaskReq_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_addTaskReq(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_batchPatch_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisebatchPatchPtr ptr = new AdminRegPrxCallbackPromise::PromisebatchPatch();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_batchPatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_batchPatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_batchPatch(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_checkDockerRegistry_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr ptr = new AdminRegPrxCallbackPromise::PromisecheckDockerRegistry();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_checkDockerRegistry_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_checkDockerRegistry_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_checkDockerRegistry(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_checkServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisecheckServerPtr ptr = new AdminRegPrxCallbackPromise::PromisecheckServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_checkServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_checkServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_checkServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_checkTicket_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisecheckTicketPtr ptr = new AdminRegPrxCallbackPromise::PromisecheckTicket();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->uid, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_checkTicket_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_checkTicket_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_checkTicket(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisedelCachePtr ptr = new AdminRegPrxCallbackPromise::PromisedelCache();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_delCache(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_deleteNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisedeleteNodePtr ptr = new AdminRegPrxCallbackPromise::PromisedeleteNode();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_deleteNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_deleteNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_deleteNode(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_deletePatchFile_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr ptr = new AdminRegPrxCallbackPromise::PromisedeletePatchFile();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_deletePatchFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_deletePatchFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_deletePatchFile(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisedestroyServerPtr ptr = new AdminRegPrxCallbackPromise::PromisedestroyServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_destroyServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_dockerPull_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisedockerPullPtr ptr = new AdminRegPrxCallbackPromise::PromisedockerPull();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_dockerPull_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_dockerPull_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_dockerPull(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr ptr = new AdminRegPrxCallbackPromise::PromiseforceDockerLogin();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_forceDockerLogin(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllApplicationNames_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr ptr = new AdminRegPrxCallbackPromise::PromisegetAllApplicationNames();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllApplicationNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllApplicationNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getAllApplicationNames(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllNodeNames_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr ptr = new AdminRegPrxCallbackPromise::PromisegetAllNodeNames();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllNodeNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllNodeNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getAllNodeNames(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllServerIds_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr ptr = new AdminRegPrxCallbackPromise::PromisegetAllServerIds();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllServerIds_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllServerIds_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getAllServerIds(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getClientIp_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetClientIpPtr ptr = new AdminRegPrxCallbackPromise::PromisegetClientIp();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->sClientIp, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getClientIp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getClientIp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getClientIp(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getConfigFileId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetConfigFileIdPtr ptr = new AdminRegPrxCallbackPromise::PromisegetConfigFileId();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->configId, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getConfigFileId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getConfigFileId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getConfigFileId(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getGroupId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetGroupIdPtr ptr = new AdminRegPrxCallbackPromise::PromisegetGroupId();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->groupId, 2, true);
                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getGroupId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getGroupId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getGroupId(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogData_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetLogDataPtr ptr = new AdminRegPrxCallbackPromise::PromisegetLogData();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->fileData, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getLogData(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetLogFileListPtr ptr = new AdminRegPrxCallbackPromise::PromisegetLogFileList();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->logFileList, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getLogFileList(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetNodeListPtr ptr = new AdminRegPrxCallbackPromise::PromisegetNodeList();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->heartbeats, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getNodeList(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr ptr = new AdminRegPrxCallbackPromise::PromisegetNodeLoad();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->fileData, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getNodeLoad(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 21:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeVesion_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr ptr = new AdminRegPrxCallbackPromise::PromisegetNodeVesion();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->version, 2, true);
                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeVesion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeVesion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getNodeVesion(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 22:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPackage_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetPatchPackagePtr ptr = new AdminRegPrxCallbackPromise::PromisegetPatchPackage();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pack, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPackage_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPackage_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getPatchPackage(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 23:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr ptr = new AdminRegPrxCallbackPromise::PromisegetPatchPercent();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->tPatchInfo, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getPatchPercent(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 24:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getProfileTemplate_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr ptr = new AdminRegPrxCallbackPromise::PromisegetProfileTemplate();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->profileTemplate, 2, true);
                        _is.read(ptr->resultDesc, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getProfileTemplate(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 25:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerNameList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetServerNameListPtr ptr = new AdminRegPrxCallbackPromise::PromisegetServerNameList();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->serverList, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerNameList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerNameList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getServerNameList(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 26:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerProfileTemplate_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr ptr = new AdminRegPrxCallbackPromise::PromisegetServerProfileTemplate();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->profileTemplate, 4, true);
                        _is.read(ptr->resultDesc, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getServerProfileTemplate(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 27:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerState_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetServerStatePtr ptr = new AdminRegPrxCallbackPromise::PromisegetServerState();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->state, 4, true);
                        _is.read(ptr->result, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getServerState(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 28:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerTree_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetServerTreePtr ptr = new AdminRegPrxCallbackPromise::PromisegetServerTree();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->tree, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerTree_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerTree_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getServerTree(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 29:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServers_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetServersPtr ptr = new AdminRegPrxCallbackPromise::PromisegetServers();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->servers, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getServers(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 30:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskHistory_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr ptr = new AdminRegPrxCallbackPromise::PromisegetTaskHistory();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->taskRsps, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskHistory_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskHistory_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getTaskHistory(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 31:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskRsp_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetTaskRspPtr ptr = new AdminRegPrxCallbackPromise::PromisegetTaskRsp();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->taskRsp, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskRsp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskRsp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getTaskRsp(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 32:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getVersion_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetVersionPtr ptr = new AdminRegPrxCallbackPromise::PromisegetVersion();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->version, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getVersion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getVersion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getVersion(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 33:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasAdminAuth_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisehasAdminAuthPtr ptr = new AdminRegPrxCallbackPromise::PromisehasAdminAuth();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        ptr->has = false;
                        _is.read(ptr->has, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_hasAdminAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_hasAdminAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_hasAdminAuth(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 34:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasDevAuth_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisehasDevAuthPtr ptr = new AdminRegPrxCallbackPromise::PromisehasDevAuth();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        ptr->has = false;
                        _is.read(ptr->has, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_hasDevAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_hasDevAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_hasDevAuth(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 35:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasOpeAuth_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisehasOpeAuthPtr ptr = new AdminRegPrxCallbackPromise::PromisehasOpeAuth();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        ptr->has = false;
                        _is.read(ptr->has, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_hasOpeAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_hasOpeAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_hasOpeAuth(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 36:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisehasServerPtr ptr = new AdminRegPrxCallbackPromise::PromisehasServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        ptr->has = false;
                        _is.read(ptr->has, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_hasServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_hasServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_hasServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 37:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertAdapterConf_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseinsertAdapterConfPtr ptr = new AdminRegPrxCallbackPromise::PromiseinsertAdapterConf();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertAdapterConf_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertAdapterConf_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_insertAdapterConf(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 38:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertConfigFile_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseinsertConfigFilePtr ptr = new AdminRegPrxCallbackPromise::PromiseinsertConfigFile();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertConfigFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertConfigFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_insertConfigFile(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 39:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertHistoryConfigFile_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseinsertHistoryConfigFilePtr ptr = new AdminRegPrxCallbackPromise::PromiseinsertHistoryConfigFile();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertHistoryConfigFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertHistoryConfigFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_insertHistoryConfigFile(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 40:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertServerConf_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseinsertServerConfPtr ptr = new AdminRegPrxCallbackPromise::PromiseinsertServerConf();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertServerConf_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertServerConf_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_insertServerConf(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 41:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseloadServerPtr ptr = new AdminRegPrxCallbackPromise::PromiseloadServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_loadServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 42:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisenotifyServerPtr ptr = new AdminRegPrxCallbackPromise::PromisenotifyServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_notifyServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 43:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_pingNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisepingNodePtr ptr = new AdminRegPrxCallbackPromise::PromisepingNode();

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_pingNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_pingNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_pingNode(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 44:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_registerPlugin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseregisterPluginPtr ptr = new AdminRegPrxCallbackPromise::PromiseregisterPlugin();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_registerPlugin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_registerPlugin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_registerPlugin(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 45:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_reportNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisereportNodePtr ptr = new AdminRegPrxCallbackPromise::PromisereportNode();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_reportNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_reportNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_reportNode(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 46:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_reportResult_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisereportResultPtr ptr = new AdminRegPrxCallbackPromise::PromisereportResult();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_reportResult_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_reportResult_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_reportResult(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 47:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_restartServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiserestartServerPtr ptr = new AdminRegPrxCallbackPromise::PromiserestartServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_restartServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_restartServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_restartServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 48:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_setTaskItemInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr ptr = new AdminRegPrxCallbackPromise::PromisesetTaskItemInfo();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_setTaskItemInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_setTaskItemInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_setTaskItemInfo(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 49:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdownNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseshutdownNodePtr ptr = new AdminRegPrxCallbackPromise::PromiseshutdownNode();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdownNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdownNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_shutdownNode(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 50:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisestartServerPtr ptr = new AdminRegPrxCallbackPromise::PromisestartServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_startServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 51:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisestopServerPtr ptr = new AdminRegPrxCallbackPromise::PromisestopServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_stopServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 52:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_undeploy_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseundeployPtr ptr = new AdminRegPrxCallbackPromise::Promiseundeploy();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->log, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_undeploy_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_undeploy_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_undeploy(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 53:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_uninstallServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseuninstallServerPtr ptr = new AdminRegPrxCallbackPromise::PromiseuninstallServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_uninstallServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_uninstallServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_uninstallServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 54:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updatePatchLog_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr ptr = new AdminRegPrxCallbackPromise::PromiseupdatePatchLog();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_updatePatchLog_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updatePatchLog_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_updatePatchLog(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 55:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updateServerFlowState_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr ptr = new AdminRegPrxCallbackPromise::PromiseupdateServerFlowState();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_updateServerFlowState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updateServerFlowState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_updateServerFlowState(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<AdminRegPrxCallbackPromise> AdminRegPrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class AdminRegCoroPrxCallback: public AdminRegPrxCallback
    {
    public:
        virtual ~AdminRegCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "checkDockerRegistry",
                "checkServer",
                "checkTicket",
                "delCache",
                "deleteNode",
                "deletePatchFile",
                "destroyServer",
                "dockerPull",
                "forceDockerLogin",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getConfigFileId",
                "getGroupId",
                "getLogData",
                "getLogFileList",
                "getNodeList",
                "getNodeLoad",
                "getNodeVesion",
                "getPatchPackage",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerNameList",
                "getServerProfileTemplate",
                "getServerState",
                "getServerTree",
                "getServers",
                "getTaskHistory",
                "getTaskRsp",
                "getVersion",
                "hasAdminAuth",
                "hasDevAuth",
                "hasOpeAuth",
                "hasServer",
                "insertAdapterConf",
                "insertConfigFile",
                "insertHistoryConfigFile",
                "insertServerConf",
                "loadServer",
                "notifyServer",
                "pingNode",
                "registerPlugin",
                "reportNode",
                "reportResult",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "uninstallServer",
                "updatePatchLog",
                "updateServerFlowState"
            };

            pair<string*, string*> r = equal_range(__AdminReg_all, __AdminReg_all+56, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __AdminReg_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_addTaskReq_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_addTaskReq(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_addTaskReq_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_addTaskReq_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_batchPatch_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_batchPatch(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_batchPatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_batchPatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_checkDockerRegistry_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_checkDockerRegistry(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_checkDockerRegistry_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_checkDockerRegistry_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_checkServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_checkServer(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_checkServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_checkServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_checkTicket_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string uid;
                        _is.read(uid, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_checkTicket(_ret, std::move(uid));

                    }
                    catch(std::exception &ex)
                    {
                        callback_checkTicket_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_checkTicket_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_delCache(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_deleteNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_deleteNode(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_deleteNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_deleteNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_deletePatchFile_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_deletePatchFile(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_deletePatchFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_deletePatchFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_destroyServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_dockerPull_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_dockerPull(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_dockerPull_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_dockerPull_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<std::string> result;
                        _is.read(result, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_forceDockerLogin(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllApplicationNames_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        vector<std::string> _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(_msg_->response->context);

                        callback_getAllApplicationNames(std::move(_ret), std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllApplicationNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllApplicationNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllNodeNames_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        vector<std::string> _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(_msg_->response->context);

                        callback_getAllNodeNames(std::move(_ret), std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllNodeNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllNodeNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllServerIds_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        vector<vector<std::string> > _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(_msg_->response->context);

                        callback_getAllServerIds(std::move(_ret), std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllServerIds_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllServerIds_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getClientIp_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string sClientIp;
                        _is.read(sClientIp, 1, true);
                        setResponseContext(_msg_->response->context);

                        callback_getClientIp(_ret, std::move(sClientIp));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getClientIp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getClientIp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getConfigFileId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Int32 configId;
                        _is.read(configId, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_getConfigFileId(_ret, configId);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getConfigFileId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getConfigFileId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getGroupId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Int32 groupId;
                        _is.read(groupId, 2, true);
                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_getGroupId(_ret, groupId, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getGroupId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getGroupId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogData_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string fileData;
                        _is.read(fileData, 6, true);
                        setResponseContext(_msg_->response->context);

                        callback_getLogData(_ret, std::move(fileData));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<std::string> logFileList;
                        _is.read(logFileList, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_getLogFileList(_ret, std::move(logFileList));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        map<std::string, std::string> heartbeats;
                        _is.read(heartbeats, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_getNodeList(_ret, std::move(heartbeats));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string fileData;
                        _is.read(fileData, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_getNodeLoad(_ret, std::move(fileData));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 21:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeVesion_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string version;
                        _is.read(version, 2, true);
                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_getNodeVesion(_ret, std::move(version), std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeVesion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeVesion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 22:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPackage_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::PatchPackage pack;
                        _is.read(pack, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_getPatchPackage(_ret, std::move(pack));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPackage_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPackage_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 23:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::PatchInfo tPatchInfo;
                        _is.read(tPatchInfo, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_getPatchPercent(_ret, std::move(tPatchInfo));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 24:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getProfileTemplate_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string profileTemplate;
                        _is.read(profileTemplate, 2, true);
                        std::string resultDesc;
                        _is.read(resultDesc, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_getProfileTemplate(_ret, std::move(profileTemplate), std::move(resultDesc));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 25:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerNameList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<map<std::string, std::string> > serverList;
                        _is.read(serverList, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_getServerNameList(_ret, std::move(serverList));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerNameList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerNameList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 26:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerProfileTemplate_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string profileTemplate;
                        _is.read(profileTemplate, 4, true);
                        std::string resultDesc;
                        _is.read(resultDesc, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_getServerProfileTemplate(_ret, std::move(profileTemplate), std::move(resultDesc));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 27:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerState_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::ServerStateDesc state;
                        _is.read(state, 4, true);
                        std::string result;
                        _is.read(result, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_getServerState(_ret, std::move(state), std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 28:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerTree_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::ServerTree> tree;
                        _is.read(tree, 1, true);
                        setResponseContext(_msg_->response->context);

                        callback_getServerTree(_ret, std::move(tree));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerTree_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerTree_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 29:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServers_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::FrameworkServer> servers;
                        _is.read(servers, 1, true);
                        setResponseContext(_msg_->response->context);

                        callback_getServers(_ret, std::move(servers));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 30:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskHistory_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::TaskRsp> taskRsps;
                        _is.read(taskRsps, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_getTaskHistory(_ret, std::move(taskRsps));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskHistory_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskHistory_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 31:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskRsp_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::TaskRsp taskRsp;
                        _is.read(taskRsp, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_getTaskRsp(_ret, std::move(taskRsp));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskRsp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskRsp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 32:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getVersion_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string version;
                        _is.read(version, 1, true);
                        setResponseContext(_msg_->response->context);

                        callback_getVersion(_ret, std::move(version));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getVersion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getVersion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 33:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasAdminAuth_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Bool has = false;
                        _is.read(has, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_hasAdminAuth(_ret, has);

                    }
                    catch(std::exception &ex)
                    {
                        callback_hasAdminAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_hasAdminAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 34:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasDevAuth_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Bool has = false;
                        _is.read(has, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_hasDevAuth(_ret, has);

                    }
                    catch(std::exception &ex)
                    {
                        callback_hasDevAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_hasDevAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 35:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasOpeAuth_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Bool has = false;
                        _is.read(has, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_hasOpeAuth(_ret, has);

                    }
                    catch(std::exception &ex)
                    {
                        callback_hasOpeAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_hasOpeAuth_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 36:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_hasServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Bool has = false;
                        _is.read(has, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_hasServer(_ret, has);

                    }
                    catch(std::exception &ex)
                    {
                        callback_hasServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_hasServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 37:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertAdapterConf_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_insertAdapterConf(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertAdapterConf_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertAdapterConf_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 38:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertConfigFile_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_insertConfigFile(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertConfigFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertConfigFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 39:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertHistoryConfigFile_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_insertHistoryConfigFile(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertHistoryConfigFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertHistoryConfigFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 40:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertServerConf_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_insertServerConf(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertServerConf_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertServerConf_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 41:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_loadServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 42:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_notifyServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 43:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_pingNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_pingNode(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_pingNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_pingNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 44:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_registerPlugin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_registerPlugin(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_registerPlugin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_registerPlugin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 45:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_reportNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_reportNode(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_reportNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_reportNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 46:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_reportResult_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_reportResult(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_reportResult_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_reportResult_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 47:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_restartServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_restartServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_restartServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_restartServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 48:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_setTaskItemInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_setTaskItemInfo(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_setTaskItemInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_setTaskItemInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 49:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdownNode_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_shutdownNode(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdownNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdownNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 50:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_startServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 51:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_stopServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 52:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_undeploy_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string log;
                        _is.read(log, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_undeploy(_ret, std::move(log));

                    }
                    catch(std::exception &ex)
                    {
                        callback_undeploy_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_undeploy_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 53:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_uninstallServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_uninstallServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_uninstallServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_uninstallServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 54:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updatePatchLog_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_updatePatchLog(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_updatePatchLog_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updatePatchLog_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 55:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updateServerFlowState_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_updateServerFlowState(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_updateServerFlowState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updateServerFlowState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<AdminRegCoroPrxCallback> AdminRegCoroPrxCallbackPtr;

    /* proxy for client */
    class AdminRegProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Int32 addTaskReq(const tars::TaskReq & taskReq,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"addTaskReq", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_addTaskReq(AdminRegPrxCallbackPtr callback,const tars::TaskReq &taskReq,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"addTaskReq", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > promise_async_addTaskReq(const tars::TaskReq &taskReq,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"addTaskReq", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_addTaskReq(AdminRegCoroPrxCallbackPtr callback,const tars::TaskReq &taskReq,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"addTaskReq", _os, context, _mStatus, callback, true);
        }

        tars::Int32 batchPatch(const tars::PatchRequest & req,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            _os.write(result, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"batchPatch", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_batchPatch(AdminRegPrxCallbackPtr callback,const tars::PatchRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"batchPatch", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > promise_async_batchPatch(const tars::PatchRequest &req,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"batchPatch", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_batchPatch(AdminRegCoroPrxCallbackPtr callback,const tars::PatchRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"batchPatch", _os, context, _mStatus, callback, true);
        }

        tars::Int32 checkDockerRegistry(const std::string & registry,const std::string & userName,const std::string & password,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(registry, 1);
            _os.write(userName, 2);
            _os.write(password, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"checkDockerRegistry", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_checkDockerRegistry(AdminRegPrxCallbackPtr callback,const std::string &registry,const std::string &userName,const std::string &password,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(registry, 1);
            _os.write(userName, 2);
            _os.write(password, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"checkDockerRegistry", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr > promise_async_checkDockerRegistry(const std::string &registry,const std::string &userName,const std::string &password,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(registry, 1);
            _os.write(userName, 2);
            _os.write(password, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"checkDockerRegistry", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_checkDockerRegistry(AdminRegCoroPrxCallbackPtr callback,const std::string &registry,const std::string &userName,const std::string &password,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(registry, 1);
            _os.write(userName, 2);
            _os.write(password, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"checkDockerRegistry", _os, context, _mStatus, callback, true);
        }

        tars::Int32 checkServer(const tars::FrameworkServer & server,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(server, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"checkServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_checkServer(AdminRegPrxCallbackPtr callback,const tars::FrameworkServer &server,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(server, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"checkServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisecheckServerPtr > promise_async_checkServer(const tars::FrameworkServer &server,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisecheckServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(server, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"checkServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_checkServer(AdminRegCoroPrxCallbackPtr callback,const tars::FrameworkServer &server,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(server, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"checkServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 checkTicket(const std::string & ticket,std::string &uid,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(ticket, 1);
            _os.write(uid, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"checkTicket", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(uid, 2, true);
            return _ret;
        }

        void async_checkTicket(AdminRegPrxCallbackPtr callback,const std::string &ticket,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(ticket, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"checkTicket", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisecheckTicketPtr > promise_async_checkTicket(const std::string &ticket,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisecheckTicketPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(ticket, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"checkTicket", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_checkTicket(AdminRegCoroPrxCallbackPtr callback,const std::string &ticket,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(ticket, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"checkTicket", _os, context, _mStatus, callback, true);
        }

        tars::Int32 delCache(const std::string & nodeName,const std::string & sFullCacheName,const std::string & sBackupPath,const std::string & sKey,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            _os.write(sFullCacheName, 2);
            _os.write(sBackupPath, 3);
            _os.write(sKey, 4);
            _os.write(result, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"delCache", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 5, true);
            return _ret;
        }

        void async_delCache(AdminRegPrxCallbackPtr callback,const std::string &nodeName,const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            _os.write(sFullCacheName, 2);
            _os.write(sBackupPath, 3);
            _os.write(sKey, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisedelCachePtr > promise_async_delCache(const std::string &nodeName,const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisedelCachePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            _os.write(sFullCacheName, 2);
            _os.write(sBackupPath, 3);
            _os.write(sKey, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_delCache(AdminRegCoroPrxCallbackPtr callback,const std::string &nodeName,const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            _os.write(sFullCacheName, 2);
            _os.write(sBackupPath, 3);
            _os.write(sKey, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os, context, _mStatus, callback, true);
        }

        tars::Int32 deleteNode(const tars::ReportNode & rn,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(rn, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"deleteNode", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_deleteNode(AdminRegPrxCallbackPtr callback,const tars::ReportNode &rn,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(rn, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"deleteNode", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisedeleteNodePtr > promise_async_deleteNode(const tars::ReportNode &rn,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisedeleteNodePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(rn, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"deleteNode", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_deleteNode(AdminRegCoroPrxCallbackPtr callback,const tars::ReportNode &rn,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(rn, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"deleteNode", _os, context, _mStatus, callback, true);
        }

        tars::Int32 deletePatchFile(const std::string & application,const std::string & serverName,const std::string & patchFile,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(patchFile, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"deletePatchFile", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_deletePatchFile(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &patchFile,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(patchFile, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"deletePatchFile", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr > promise_async_deletePatchFile(const std::string &application,const std::string &serverName,const std::string &patchFile,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(patchFile, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"deletePatchFile", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_deletePatchFile(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &patchFile,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(patchFile, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"deletePatchFile", _os, context, _mStatus, callback, true);
        }

        tars::Int32 destroyServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_destroyServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisedestroyServerPtr > promise_async_destroyServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisedestroyServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_destroyServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 dockerPull(const std::string & baseImageId,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(baseImageId, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"dockerPull", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_dockerPull(AdminRegPrxCallbackPtr callback,const std::string &baseImageId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(baseImageId, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"dockerPull", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisedockerPullPtr > promise_async_dockerPull(const std::string &baseImageId,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisedockerPullPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(baseImageId, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"dockerPull", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_dockerPull(AdminRegCoroPrxCallbackPtr callback,const std::string &baseImageId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(baseImageId, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"dockerPull", _os, context, _mStatus, callback, true);
        }

        tars::Int32 forceDockerLogin(const std::string & nodeName,vector<std::string> &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            _os.write(result, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_forceDockerLogin(AdminRegPrxCallbackPtr callback,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr > promise_async_forceDockerLogin(const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_forceDockerLogin(AdminRegCoroPrxCallbackPtr callback,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus, callback, true);
        }

        vector<std::string> getAllApplicationNames(std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getAllApplicationNames", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            vector<std::string> _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_getAllApplicationNames(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllApplicationNames", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > promise_async_getAllApplicationNames(const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllApplicationNames", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getAllApplicationNames(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllApplicationNames", _os, context, _mStatus, callback, true);
        }

        vector<std::string> getAllNodeNames(std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getAllNodeNames", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            vector<std::string> _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_getAllNodeNames(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllNodeNames", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > promise_async_getAllNodeNames(const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllNodeNames", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getAllNodeNames(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllNodeNames", _os, context, _mStatus, callback, true);
        }

        vector<vector<std::string> > getAllServerIds(std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getAllServerIds", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            vector<vector<std::string> > _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_getAllServerIds(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllServerIds", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > promise_async_getAllServerIds(const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllServerIds", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getAllServerIds(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllServerIds", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getClientIp(std::string &sClientIp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sClientIp, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getClientIp", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(sClientIp, 1, true);
            return _ret;
        }

        void async_getClientIp(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getClientIp", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > promise_async_getClientIp(const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getClientIp", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getClientIp(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getClientIp", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getConfigFileId(const std::string & sFullServerName,const std::string & fileName,const std::string & nodeName,tars::Int32 level,tars::Int32 &configId,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullServerName, 1);
            _os.write(fileName, 2);
            _os.write(nodeName, 3);
            _os.write(level, 4);
            _os.write(configId, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getConfigFileId", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(configId, 5, true);
            return _ret;
        }

        void async_getConfigFileId(AdminRegPrxCallbackPtr callback,const std::string &sFullServerName,const std::string &fileName,const std::string &nodeName,tars::Int32 level,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullServerName, 1);
            _os.write(fileName, 2);
            _os.write(nodeName, 3);
            _os.write(level, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getConfigFileId", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetConfigFileIdPtr > promise_async_getConfigFileId(const std::string &sFullServerName,const std::string &fileName,const std::string &nodeName,tars::Int32 level,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetConfigFileIdPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullServerName, 1);
            _os.write(fileName, 2);
            _os.write(nodeName, 3);
            _os.write(level, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getConfigFileId", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getConfigFileId(AdminRegCoroPrxCallbackPtr callback,const std::string &sFullServerName,const std::string &fileName,const std::string &nodeName,tars::Int32 level,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullServerName, 1);
            _os.write(fileName, 2);
            _os.write(nodeName, 3);
            _os.write(level, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getConfigFileId", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getGroupId(const std::string & ip,tars::Int32 &groupId,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(ip, 1);
            _os.write(groupId, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getGroupId", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(groupId, 2, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getGroupId(AdminRegPrxCallbackPtr callback,const std::string &ip,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(ip, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getGroupId", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > promise_async_getGroupId(const std::string &ip,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(ip, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getGroupId", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getGroupId(AdminRegCoroPrxCallbackPtr callback,const std::string &ip,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(ip, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getGroupId", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getLogData(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & logFile,const std::string & cmd,std::string &fileData,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(logFile, 4);
            _os.write(cmd, 5);
            _os.write(fileData, 6);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getLogData", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(fileData, 6, true);
            return _ret;
        }

        void async_getLogData(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &logFile,const std::string &cmd,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(logFile, 4);
            _os.write(cmd, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogData", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetLogDataPtr > promise_async_getLogData(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &logFile,const std::string &cmd,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetLogDataPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(logFile, 4);
            _os.write(cmd, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogData", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLogData(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &logFile,const std::string &cmd,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(logFile, 4);
            _os.write(cmd, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogData", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getLogFileList(const std::string & application,const std::string & serverName,const std::string & nodeName,vector<std::string> &logFileList,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(logFileList, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(logFileList, 4, true);
            return _ret;
        }

        void async_getLogFileList(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetLogFileListPtr > promise_async_getLogFileList(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetLogFileListPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLogFileList(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getNodeList(const vector<std::string> & nodeNames,map<std::string, std::string> &heartbeats,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeNames, 1);
            _os.write(heartbeats, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getNodeList", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(heartbeats, 2, true);
            return _ret;
        }

        void async_getNodeList(AdminRegPrxCallbackPtr callback,const vector<std::string> &nodeNames,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeNames, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeList", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetNodeListPtr > promise_async_getNodeList(const vector<std::string> &nodeNames,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetNodeListPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeNames, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeList", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getNodeList(AdminRegCoroPrxCallbackPtr callback,const vector<std::string> &nodeNames,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(nodeNames, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeList", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getNodeLoad(const std::string & application,const std::string & serverName,const std::string & nodeName,tars::Int32 pid,std::string &fileData,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(pid, 4);
            _os.write(fileData, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(fileData, 5, true);
            return _ret;
        }

        void async_getNodeLoad(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,tars::Int32 pid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(pid, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr > promise_async_getNodeLoad(const std::string &application,const std::string &serverName,const std::string &nodeName,tars::Int32 pid,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(pid, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getNodeLoad(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,tars::Int32 pid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(pid, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getNodeVesion(const std::string & name,std::string &version,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            _os.write(version, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getNodeVesion", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(version, 2, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getNodeVesion(AdminRegPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeVesion", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > promise_async_getNodeVesion(const std::string &name,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeVesion", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getNodeVesion(AdminRegCoroPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeVesion", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getPatchPackage(const std::string & application,const std::string & serverName,tars::Int32 packageType,tars::Int32 defaultVersion,tars::PatchPackage &pack,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(packageType, 3);
            _os.write(defaultVersion, 4);
            _os.write(pack, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getPatchPackage", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pack, 5, true);
            return _ret;
        }

        void async_getPatchPackage(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,tars::Int32 packageType,tars::Int32 defaultVersion,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(packageType, 3);
            _os.write(defaultVersion, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPackage", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetPatchPackagePtr > promise_async_getPatchPackage(const std::string &application,const std::string &serverName,tars::Int32 packageType,tars::Int32 defaultVersion,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPackagePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(packageType, 3);
            _os.write(defaultVersion, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPackage", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getPatchPackage(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,tars::Int32 packageType,tars::Int32 defaultVersion,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(packageType, 3);
            _os.write(defaultVersion, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPackage", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getPatchPercent(const std::string & application,const std::string & serverName,const std::string & nodeName,tars::PatchInfo &tPatchInfo,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(tPatchInfo, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tPatchInfo, 4, true);
            return _ret;
        }

        void async_getPatchPercent(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > promise_async_getPatchPercent(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getPatchPercent(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getProfileTemplate(const std::string & profileName,std::string &profileTemplate,std::string &resultDesc,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(profileName, 1);
            _os.write(profileTemplate, 2);
            _os.write(resultDesc, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getProfileTemplate", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(profileTemplate, 2, true);
            _is.read(resultDesc, 3, true);
            return _ret;
        }

        void async_getProfileTemplate(AdminRegPrxCallbackPtr callback,const std::string &profileName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(profileName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getProfileTemplate", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > promise_async_getProfileTemplate(const std::string &profileName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(profileName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getProfileTemplate", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getProfileTemplate(AdminRegCoroPrxCallbackPtr callback,const std::string &profileName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(profileName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getProfileTemplate", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getServerNameList(const vector<tars::ApplicationServerName> & fullServerName,vector<map<std::string, std::string> > &serverList,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(fullServerName, 1);
            _os.write(serverList, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getServerNameList", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(serverList, 2, true);
            return _ret;
        }

        void async_getServerNameList(AdminRegPrxCallbackPtr callback,const vector<tars::ApplicationServerName> &fullServerName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(fullServerName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerNameList", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetServerNameListPtr > promise_async_getServerNameList(const vector<tars::ApplicationServerName> &fullServerName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerNameListPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(fullServerName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerNameList", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServerNameList(AdminRegCoroPrxCallbackPtr callback,const vector<tars::ApplicationServerName> &fullServerName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(fullServerName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerNameList", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getServerProfileTemplate(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &profileTemplate,std::string &resultDesc,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(profileTemplate, 4);
            _os.write(resultDesc, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getServerProfileTemplate", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(profileTemplate, 4, true);
            _is.read(resultDesc, 5, true);
            return _ret;
        }

        void async_getServerProfileTemplate(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerProfileTemplate", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > promise_async_getServerProfileTemplate(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerProfileTemplate", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServerProfileTemplate(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerProfileTemplate", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getServerState(const std::string & application,const std::string & serverName,const std::string & nodeName,tars::ServerStateDesc &state,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(state, 4);
            _os.write(result, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getServerState", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(state, 4, true);
            _is.read(result, 5, true);
            return _ret;
        }

        void async_getServerState(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerState", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > promise_async_getServerState(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerState", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServerState(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerState", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getServerTree(vector<tars::ServerTree> &tree,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tree, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getServerTree", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tree, 1, true);
            return _ret;
        }

        void async_getServerTree(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerTree", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetServerTreePtr > promise_async_getServerTree(const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetServerTreePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerTree", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServerTree(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerTree", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getServers(vector<tars::FrameworkServer> &servers,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(servers, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getServers", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(servers, 1, true);
            return _ret;
        }

        void async_getServers(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServers", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetServersPtr > promise_async_getServers(const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetServersPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServers", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServers(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServers", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getTaskHistory(const std::string & application,const std::string & serverName,const std::string & command,vector<tars::TaskRsp> &taskRsps,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            _os.write(taskRsps, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getTaskHistory", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(taskRsps, 4, true);
            return _ret;
        }

        void async_getTaskHistory(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskHistory", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > promise_async_getTaskHistory(const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskHistory", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getTaskHistory(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskHistory", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getTaskRsp(const std::string & taskNo,tars::TaskRsp &taskRsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(taskNo, 1);
            _os.write(taskRsp, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getTaskRsp", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(taskRsp, 2, true);
            return _ret;
        }

        void async_getTaskRsp(AdminRegPrxCallbackPtr callback,const std::string &taskNo,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(taskNo, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskRsp", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > promise_async_getTaskRsp(const std::string &taskNo,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(taskNo, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskRsp", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getTaskRsp(AdminRegCoroPrxCallbackPtr callback,const std::string &taskNo,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(taskNo, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskRsp", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getVersion(std::string &version,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(version, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getVersion", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(version, 1, true);
            return _ret;
        }

        void async_getVersion(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getVersion", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisegetVersionPtr > promise_async_getVersion(const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisegetVersionPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getVersion", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getVersion(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getVersion", _os, context, _mStatus, callback, true);
        }

        tars::Int32 hasAdminAuth(const std::string & uid,tars::Bool &has,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(uid, 1);
            _os.write(has, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"hasAdminAuth", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(has, 2, true);
            return _ret;
        }

        void async_hasAdminAuth(AdminRegPrxCallbackPtr callback,const std::string &uid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(uid, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasAdminAuth", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisehasAdminAuthPtr > promise_async_hasAdminAuth(const std::string &uid,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisehasAdminAuthPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(uid, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasAdminAuth", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_hasAdminAuth(AdminRegCoroPrxCallbackPtr callback,const std::string &uid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(uid, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasAdminAuth", _os, context, _mStatus, callback, true);
        }

        tars::Int32 hasDevAuth(const std::string & application,const std::string & serverName,const std::string & uid,tars::Bool &has,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(uid, 3);
            _os.write(has, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"hasDevAuth", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(has, 4, true);
            return _ret;
        }

        void async_hasDevAuth(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &uid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(uid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasDevAuth", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisehasDevAuthPtr > promise_async_hasDevAuth(const std::string &application,const std::string &serverName,const std::string &uid,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisehasDevAuthPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(uid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasDevAuth", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_hasDevAuth(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &uid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(uid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasDevAuth", _os, context, _mStatus, callback, true);
        }

        tars::Int32 hasOpeAuth(const std::string & application,const std::string & serverName,const std::string & uid,tars::Bool &has,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(uid, 3);
            _os.write(has, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"hasOpeAuth", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(has, 4, true);
            return _ret;
        }

        void async_hasOpeAuth(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &uid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(uid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasOpeAuth", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisehasOpeAuthPtr > promise_async_hasOpeAuth(const std::string &application,const std::string &serverName,const std::string &uid,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisehasOpeAuthPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(uid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasOpeAuth", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_hasOpeAuth(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &uid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(uid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasOpeAuth", _os, context, _mStatus, callback, true);
        }

        tars::Int32 hasServer(const std::string & application,const std::string & serverName,tars::Bool &has,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(has, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"hasServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(has, 3, true);
            return _ret;
        }

        void async_hasServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisehasServerPtr > promise_async_hasServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisehasServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_hasServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"hasServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 insertAdapterConf(const std::string & sApplication,const std::string & serverName,const std::string & nodeName,const tars::AdapterConf & conf,tars::Bool replace,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sApplication, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(conf, 4);
            _os.write(replace, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"insertAdapterConf", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_insertAdapterConf(AdminRegPrxCallbackPtr callback,const std::string &sApplication,const std::string &serverName,const std::string &nodeName,const tars::AdapterConf &conf,tars::Bool replace,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sApplication, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(conf, 4);
            _os.write(replace, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertAdapterConf", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseinsertAdapterConfPtr > promise_async_insertAdapterConf(const std::string &sApplication,const std::string &serverName,const std::string &nodeName,const tars::AdapterConf &conf,tars::Bool replace,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertAdapterConfPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sApplication, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(conf, 4);
            _os.write(replace, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertAdapterConf", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_insertAdapterConf(AdminRegCoroPrxCallbackPtr callback,const std::string &sApplication,const std::string &serverName,const std::string &nodeName,const tars::AdapterConf &conf,tars::Bool replace,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sApplication, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(conf, 4);
            _os.write(replace, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertAdapterConf", _os, context, _mStatus, callback, true);
        }

        tars::Int32 insertConfigFile(const std::string & sFullServerName,const std::string & fileName,const std::string & content,const std::string & nodeName,tars::Int32 level,tars::Bool replace,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullServerName, 1);
            _os.write(fileName, 2);
            _os.write(content, 3);
            _os.write(nodeName, 4);
            _os.write(level, 5);
            _os.write(replace, 6);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"insertConfigFile", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_insertConfigFile(AdminRegPrxCallbackPtr callback,const std::string &sFullServerName,const std::string &fileName,const std::string &content,const std::string &nodeName,tars::Int32 level,tars::Bool replace,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullServerName, 1);
            _os.write(fileName, 2);
            _os.write(content, 3);
            _os.write(nodeName, 4);
            _os.write(level, 5);
            _os.write(replace, 6);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertConfigFile", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseinsertConfigFilePtr > promise_async_insertConfigFile(const std::string &sFullServerName,const std::string &fileName,const std::string &content,const std::string &nodeName,tars::Int32 level,tars::Bool replace,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertConfigFilePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullServerName, 1);
            _os.write(fileName, 2);
            _os.write(content, 3);
            _os.write(nodeName, 4);
            _os.write(level, 5);
            _os.write(replace, 6);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertConfigFile", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_insertConfigFile(AdminRegCoroPrxCallbackPtr callback,const std::string &sFullServerName,const std::string &fileName,const std::string &content,const std::string &nodeName,tars::Int32 level,tars::Bool replace,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullServerName, 1);
            _os.write(fileName, 2);
            _os.write(content, 3);
            _os.write(nodeName, 4);
            _os.write(level, 5);
            _os.write(replace, 6);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertConfigFile", _os, context, _mStatus, callback, true);
        }

        tars::Int32 insertHistoryConfigFile(tars::Int32 configId,const std::string & reason,const std::string & content,tars::Bool replace,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(configId, 1);
            _os.write(reason, 2);
            _os.write(content, 3);
            _os.write(replace, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"insertHistoryConfigFile", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_insertHistoryConfigFile(AdminRegPrxCallbackPtr callback,tars::Int32 configId,const std::string &reason,const std::string &content,tars::Bool replace,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(configId, 1);
            _os.write(reason, 2);
            _os.write(content, 3);
            _os.write(replace, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertHistoryConfigFile", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseinsertHistoryConfigFilePtr > promise_async_insertHistoryConfigFile(tars::Int32 configId,const std::string &reason,const std::string &content,tars::Bool replace,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertHistoryConfigFilePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(configId, 1);
            _os.write(reason, 2);
            _os.write(content, 3);
            _os.write(replace, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertHistoryConfigFile", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_insertHistoryConfigFile(AdminRegCoroPrxCallbackPtr callback,tars::Int32 configId,const std::string &reason,const std::string &content,tars::Bool replace,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(configId, 1);
            _os.write(reason, 2);
            _os.write(content, 3);
            _os.write(replace, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertHistoryConfigFile", _os, context, _mStatus, callback, true);
        }

        tars::Int32 insertServerConf(const tars::ServerConf & conf,tars::Bool replace,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(conf, 1);
            _os.write(replace, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"insertServerConf", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_insertServerConf(AdminRegPrxCallbackPtr callback,const tars::ServerConf &conf,tars::Bool replace,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(conf, 1);
            _os.write(replace, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertServerConf", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseinsertServerConfPtr > promise_async_insertServerConf(const tars::ServerConf &conf,tars::Bool replace,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseinsertServerConfPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(conf, 1);
            _os.write(replace, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertServerConf", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_insertServerConf(AdminRegCoroPrxCallbackPtr callback,const tars::ServerConf &conf,tars::Bool replace,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(conf, 1);
            _os.write(replace, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertServerConf", _os, context, _mStatus, callback, true);
        }

        tars::Int32 loadServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"loadServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_loadServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseloadServerPtr > promise_async_loadServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseloadServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_loadServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & command,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            _os.write(result, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 5, true);
            return _ret;
        }

        void async_notifyServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > promise_async_notifyServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &command,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_notifyServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus, callback, true);
        }

        tars::Bool pingNode(const std::string & name,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            _os.write(result, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"pingNode", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_pingNode(AdminRegPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"pingNode", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisepingNodePtr > promise_async_pingNode(const std::string &name,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisepingNodePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"pingNode", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_pingNode(AdminRegCoroPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"pingNode", _os, context, _mStatus, callback, true);
        }

        tars::Int32 registerPlugin(const tars::PluginConf & conf,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(conf, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"registerPlugin", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_registerPlugin(AdminRegPrxCallbackPtr callback,const tars::PluginConf &conf,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(conf, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"registerPlugin", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseregisterPluginPtr > promise_async_registerPlugin(const tars::PluginConf &conf,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseregisterPluginPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(conf, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"registerPlugin", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_registerPlugin(AdminRegCoroPrxCallbackPtr callback,const tars::PluginConf &conf,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(conf, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"registerPlugin", _os, context, _mStatus, callback, true);
        }

        tars::Int32 reportNode(const tars::ReportNode & rn,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(rn, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"reportNode", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_reportNode(AdminRegPrxCallbackPtr callback,const tars::ReportNode &rn,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(rn, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"reportNode", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisereportNodePtr > promise_async_reportNode(const tars::ReportNode &rn,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisereportNodePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(rn, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"reportNode", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_reportNode(AdminRegCoroPrxCallbackPtr callback,const tars::ReportNode &rn,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(rn, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"reportNode", _os, context, _mStatus, callback, true);
        }

        tars::Int32 reportResult(tars::Int32 requestId,const std::string & funcName,tars::Int32 ret,const std::string & result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(funcName, 2);
            _os.write(ret, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"reportResult", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_reportResult(AdminRegPrxCallbackPtr callback,tars::Int32 requestId,const std::string &funcName,tars::Int32 ret,const std::string &result,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(funcName, 2);
            _os.write(ret, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"reportResult", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisereportResultPtr > promise_async_reportResult(tars::Int32 requestId,const std::string &funcName,tars::Int32 ret,const std::string &result,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisereportResultPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(funcName, 2);
            _os.write(ret, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"reportResult", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_reportResult(AdminRegCoroPrxCallbackPtr callback,tars::Int32 requestId,const std::string &funcName,tars::Int32 ret,const std::string &result,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(funcName, 2);
            _os.write(ret, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"reportResult", _os, context, _mStatus, callback, true);
        }

        tars::Int32 restartServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"restartServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_restartServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"restartServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiserestartServerPtr > promise_async_restartServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiserestartServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"restartServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_restartServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"restartServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 setTaskItemInfo(const std::string & itemNo,const map<std::string, std::string> & info,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"setTaskItemInfo", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_setTaskItemInfo(AdminRegPrxCallbackPtr callback,const std::string &itemNo,const map<std::string, std::string> &info,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"setTaskItemInfo", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > promise_async_setTaskItemInfo(const std::string &itemNo,const map<std::string, std::string> &info,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"setTaskItemInfo", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_setTaskItemInfo(AdminRegCoroPrxCallbackPtr callback,const std::string &itemNo,const map<std::string, std::string> &info,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"setTaskItemInfo", _os, context, _mStatus, callback, true);
        }

        tars::Int32 shutdownNode(const std::string & name,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            _os.write(result, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"shutdownNode", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_shutdownNode(AdminRegPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdownNode", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > promise_async_shutdownNode(const std::string &name,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdownNode", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_shutdownNode(AdminRegCoroPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdownNode", _os, context, _mStatus, callback, true);
        }

        tars::Int32 startServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"startServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_startServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisestartServerPtr > promise_async_startServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisestartServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_startServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 stopServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"stopServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_stopServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromisestopServerPtr > promise_async_stopServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromisestopServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 undeploy(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & user,std::string &log,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            _os.write(log, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"undeploy", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(log, 5, true);
            return _ret;
        }

        void async_undeploy(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &user,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"undeploy", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseundeployPtr > promise_async_undeploy(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &user,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseundeployPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"undeploy", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_undeploy(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &user,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"undeploy", _os, context, _mStatus, callback, true);
        }

        tars::Int32 uninstallServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"uninstallServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_uninstallServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"uninstallServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseuninstallServerPtr > promise_async_uninstallServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseuninstallServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"uninstallServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_uninstallServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"uninstallServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 updatePatchLog(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & patchId,const std::string & user,const std::string & patchType,tars::Bool succ,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"updatePatchLog", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_updatePatchLog(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &patchId,const std::string &user,const std::string &patchType,tars::Bool succ,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updatePatchLog", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > promise_async_updatePatchLog(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &patchId,const std::string &user,const std::string &patchType,tars::Bool succ,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updatePatchLog", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_updatePatchLog(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &patchId,const std::string &user,const std::string &patchType,tars::Bool succ,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updatePatchLog", _os, context, _mStatus, callback, true);
        }

        tars::Int32 updateServerFlowState(const std::string & application,const std::string & serverName,const vector<std::string> & nodeList,tars::Bool bActive,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeList, 3);
            _os.write(bActive, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"updateServerFlowState", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_updateServerFlowState(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const vector<std::string> &nodeList,tars::Bool bActive,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeList, 3);
            _os.write(bActive, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updateServerFlowState", _os, context, _mStatus, callback);
        }
        
        tars::Future< AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr > promise_async_updateServerFlowState(const std::string &application,const std::string &serverName,const vector<std::string> &nodeList,tars::Bool bActive,const map<string, string>& context)
        {
            tars::Promise< AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeList, 3);
            _os.write(bActive, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updateServerFlowState", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_updateServerFlowState(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const vector<std::string> &nodeList,tars::Bool bActive,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeList, 3);
            _os.write(bActive, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updateServerFlowState", _os, context, _mStatus, callback, true);
        }

        AdminRegProxy* tars_hash(uint32_t key)
        {
            return (AdminRegProxy*)ServantProxy::tars_hash(key);
        }

        AdminRegProxy* tars_consistent_hash(uint32_t key)
        {
            return (AdminRegProxy*)ServantProxy::tars_consistent_hash(key);
        }

        AdminRegProxy* tars_open_trace(bool traceParam = false)
        {
            return (AdminRegProxy*)ServantProxy::tars_open_trace(traceParam);
        }

        AdminRegProxy* tars_set_timeout(int msecond)
        {
            return (AdminRegProxy*)ServantProxy::tars_set_timeout(msecond);
        }

        static const char* tars_prxname() { return "AdminRegProxy"; }
    };
    typedef tars::TC_AutoPtr<AdminRegProxy> AdminRegPrx;

    /* servant for server */
    class AdminReg : public tars::Servant
    {
    public:
        virtual ~AdminReg(){}
        virtual tars::Int32 addTaskReq(const tars::TaskReq & taskReq,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 addTaskReq(tars::TaskReq && taskReq,tars::TarsCurrentPtr _current_) 
        { return addTaskReq(taskReq, _current_); }
        static void async_response_addTaskReq(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_addTaskReq(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"addTaskReq", _os, _context);
            }
        }

        virtual tars::Int32 batchPatch(const tars::PatchRequest & req,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 batchPatch(tars::PatchRequest && req,std::string &result,tars::TarsCurrentPtr _current_) 
        { return batchPatch(req, result, _current_); }
        static void async_response_batchPatch(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_batchPatch(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"batchPatch", _os, _context);
            }
        }

        virtual tars::Int32 checkDockerRegistry(const std::string & registry,const std::string & userName,const std::string & password,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 checkDockerRegistry(std::string && registry,std::string && userName,std::string && password,std::string &result,tars::TarsCurrentPtr _current_) 
        { return checkDockerRegistry(registry, userName, password, result, _current_); }
        static void async_response_checkDockerRegistry(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_checkDockerRegistry(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"checkDockerRegistry", _os, _context);
            }
        }

        virtual tars::Int32 checkServer(const tars::FrameworkServer & server,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 checkServer(tars::FrameworkServer && server,tars::TarsCurrentPtr _current_) 
        { return checkServer(server, _current_); }
        static void async_response_checkServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_checkServer(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"checkServer", _os, _context);
            }
        }

        virtual tars::Int32 checkTicket(const std::string & ticket,std::string &uid,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 checkTicket(std::string && ticket,std::string &uid,tars::TarsCurrentPtr _current_) 
        { return checkTicket(ticket, uid, _current_); }
        static void async_response_checkTicket(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &uid)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("uid", uid);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["uid"] = tars::JsonOutput::writeJson(uid);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(uid, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_checkTicket(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &uid, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(uid, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"checkTicket", _os, _context);
            }
        }

        virtual tars::Int32 delCache(const std::string & nodeName,const std::string & sFullCacheName,const std::string & sBackupPath,const std::string & sKey,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 delCache(std::string && nodeName,std::string && sFullCacheName,std::string && sBackupPath,std::string && sKey,std::string &result,tars::TarsCurrentPtr _current_) 
        { return delCache(nodeName, sFullCacheName, sBackupPath, sKey, result, _current_); }
        static void async_response_delCache(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_delCache(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"delCache", _os, _context);
            }
        }

        virtual tars::Int32 deleteNode(const tars::ReportNode & rn,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 deleteNode(tars::ReportNode && rn,tars::TarsCurrentPtr _current_) 
        { return deleteNode(rn, _current_); }
        static void async_response_deleteNode(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_deleteNode(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"deleteNode", _os, _context);
            }
        }

        virtual tars::Int32 deletePatchFile(const std::string & application,const std::string & serverName,const std::string & patchFile,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 deletePatchFile(std::string && application,std::string && serverName,std::string && patchFile,tars::TarsCurrentPtr _current_) 
        { return deletePatchFile(application, serverName, patchFile, _current_); }
        static void async_response_deletePatchFile(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_deletePatchFile(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"deletePatchFile", _os, _context);
            }
        }

        virtual tars::Int32 destroyServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 destroyServer(std::string && application,std::string && serverName,std::string && nodeName,std::string &result,tars::TarsCurrentPtr _current_) 
        { return destroyServer(application, serverName, nodeName, result, _current_); }
        static void async_response_destroyServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_destroyServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"destroyServer", _os, _context);
            }
        }

        virtual tars::Int32 dockerPull(const std::string & baseImageId,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 dockerPull(std::string && baseImageId,tars::TarsCurrentPtr _current_) 
        { return dockerPull(baseImageId, _current_); }
        static void async_response_dockerPull(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_dockerPull(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"dockerPull", _os, _context);
            }
        }

        virtual tars::Int32 forceDockerLogin(const std::string & nodeName,vector<std::string> &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 forceDockerLogin(std::string && nodeName,vector<std::string> &result,tars::TarsCurrentPtr _current_) 
        { return forceDockerLogin(nodeName, result, _current_); }
        static void async_response_forceDockerLogin(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<std::string> &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_forceDockerLogin(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<std::string> &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"forceDockerLogin", _os, _context);
            }
        }

        virtual vector<std::string> getAllApplicationNames(std::string &result,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getAllApplicationNames(tars::TarsCurrentPtr _current_, const vector<std::string> &_ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getAllApplicationNames(tars::CurrentPtr _current_, const vector<std::string> &_ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getAllApplicationNames", _os, _context);
            }
        }

        virtual vector<std::string> getAllNodeNames(std::string &result,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getAllNodeNames(tars::TarsCurrentPtr _current_, const vector<std::string> &_ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getAllNodeNames(tars::CurrentPtr _current_, const vector<std::string> &_ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getAllNodeNames", _os, _context);
            }
        }

        virtual vector<vector<std::string> > getAllServerIds(std::string &result,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getAllServerIds(tars::TarsCurrentPtr _current_, const vector<vector<std::string> > &_ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getAllServerIds(tars::CurrentPtr _current_, const vector<vector<std::string> > &_ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getAllServerIds", _os, _context);
            }
        }

        virtual tars::Int32 getClientIp(std::string &sClientIp,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getClientIp(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &sClientIp)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("sClientIp", sClientIp);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["sClientIp"] = tars::JsonOutput::writeJson(sClientIp);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(sClientIp, 1);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getClientIp(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &sClientIp, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(sClientIp, 1);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getClientIp", _os, _context);
            }
        }

        virtual tars::Int32 getConfigFileId(const std::string & sFullServerName,const std::string & fileName,const std::string & nodeName,tars::Int32 level,tars::Int32 &configId,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getConfigFileId(std::string && sFullServerName,std::string && fileName,std::string && nodeName,tars::Int32 level,tars::Int32 &configId,tars::TarsCurrentPtr _current_) 
        { return getConfigFileId(sFullServerName, fileName, nodeName, level, configId, _current_); }
        static void async_response_getConfigFileId(tars::TarsCurrentPtr _current_, tars::Int32 _ret, tars::Int32 configId)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("configId", configId);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["configId"] = tars::JsonOutput::writeJson(configId);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(configId, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getConfigFileId(tars::CurrentPtr _current_, tars::Int32 _ret, tars::Int32 configId, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(configId, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getConfigFileId", _os, _context);
            }
        }

        virtual tars::Int32 getGroupId(const std::string & ip,tars::Int32 &groupId,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getGroupId(std::string && ip,tars::Int32 &groupId,std::string &result,tars::TarsCurrentPtr _current_) 
        { return getGroupId(ip, groupId, result, _current_); }
        static void async_response_getGroupId(tars::TarsCurrentPtr _current_, tars::Int32 _ret, tars::Int32 groupId, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("groupId", groupId);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["groupId"] = tars::JsonOutput::writeJson(groupId);
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(groupId, 2);

                _os.write(result, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getGroupId(tars::CurrentPtr _current_, tars::Int32 _ret, tars::Int32 groupId, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(groupId, 2);

                _os.write(result, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getGroupId", _os, _context);
            }
        }

        virtual tars::Int32 getLogData(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & logFile,const std::string & cmd,std::string &fileData,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getLogData(std::string && application,std::string && serverName,std::string && nodeName,std::string && logFile,std::string && cmd,std::string &fileData,tars::TarsCurrentPtr _current_) 
        { return getLogData(application, serverName, nodeName, logFile, cmd, fileData, _current_); }
        static void async_response_getLogData(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &fileData)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("fileData", fileData);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["fileData"] = tars::JsonOutput::writeJson(fileData);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 6);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getLogData(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &fileData, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 6);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getLogData", _os, _context);
            }
        }

        virtual tars::Int32 getLogFileList(const std::string & application,const std::string & serverName,const std::string & nodeName,vector<std::string> &logFileList,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getLogFileList(std::string && application,std::string && serverName,std::string && nodeName,vector<std::string> &logFileList,tars::TarsCurrentPtr _current_) 
        { return getLogFileList(application, serverName, nodeName, logFileList, _current_); }
        static void async_response_getLogFileList(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<std::string> &logFileList)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("logFileList", logFileList);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["logFileList"] = tars::JsonOutput::writeJson(logFileList);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(logFileList, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getLogFileList(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<std::string> &logFileList, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(logFileList, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getLogFileList", _os, _context);
            }
        }

        virtual tars::Int32 getNodeList(const vector<std::string> & nodeNames,map<std::string, std::string> &heartbeats,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getNodeList(vector<std::string> && nodeNames,map<std::string, std::string> &heartbeats,tars::TarsCurrentPtr _current_) 
        { return getNodeList(nodeNames, heartbeats, _current_); }
        static void async_response_getNodeList(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const map<std::string, std::string> &heartbeats)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("heartbeats", heartbeats);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["heartbeats"] = tars::JsonOutput::writeJson(heartbeats);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(heartbeats, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getNodeList(tars::CurrentPtr _current_, tars::Int32 _ret, const map<std::string, std::string> &heartbeats, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(heartbeats, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getNodeList", _os, _context);
            }
        }

        virtual tars::Int32 getNodeLoad(const std::string & application,const std::string & serverName,const std::string & nodeName,tars::Int32 pid,std::string &fileData,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getNodeLoad(std::string && application,std::string && serverName,std::string && nodeName,tars::Int32 pid,std::string &fileData,tars::TarsCurrentPtr _current_) 
        { return getNodeLoad(application, serverName, nodeName, pid, fileData, _current_); }
        static void async_response_getNodeLoad(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &fileData)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("fileData", fileData);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["fileData"] = tars::JsonOutput::writeJson(fileData);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getNodeLoad(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &fileData, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getNodeLoad", _os, _context);
            }
        }

        virtual tars::Int32 getNodeVesion(const std::string & name,std::string &version,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getNodeVesion(std::string && name,std::string &version,std::string &result,tars::TarsCurrentPtr _current_) 
        { return getNodeVesion(name, version, result, _current_); }
        static void async_response_getNodeVesion(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &version, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("version", version);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["version"] = tars::JsonOutput::writeJson(version);
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(version, 2);

                _os.write(result, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getNodeVesion(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &version, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(version, 2);

                _os.write(result, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getNodeVesion", _os, _context);
            }
        }

        virtual tars::Int32 getPatchPackage(const std::string & application,const std::string & serverName,tars::Int32 packageType,tars::Int32 defaultVersion,tars::PatchPackage &pack,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getPatchPackage(std::string && application,std::string && serverName,tars::Int32 packageType,tars::Int32 defaultVersion,tars::PatchPackage &pack,tars::TarsCurrentPtr _current_) 
        { return getPatchPackage(application, serverName, packageType, defaultVersion, pack, _current_); }
        static void async_response_getPatchPackage(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const tars::PatchPackage &pack)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pack", pack);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pack"] = tars::JsonOutput::writeJson(pack);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pack, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getPatchPackage(tars::CurrentPtr _current_, tars::Int32 _ret, const tars::PatchPackage &pack, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pack, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getPatchPackage", _os, _context);
            }
        }

        virtual tars::Int32 getPatchPercent(const std::string & application,const std::string & serverName,const std::string & nodeName,tars::PatchInfo &tPatchInfo,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getPatchPercent(std::string && application,std::string && serverName,std::string && nodeName,tars::PatchInfo &tPatchInfo,tars::TarsCurrentPtr _current_) 
        { return getPatchPercent(application, serverName, nodeName, tPatchInfo, _current_); }
        static void async_response_getPatchPercent(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const tars::PatchInfo &tPatchInfo)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("tPatchInfo", tPatchInfo);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tPatchInfo"] = tars::JsonOutput::writeJson(tPatchInfo);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tPatchInfo, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getPatchPercent(tars::CurrentPtr _current_, tars::Int32 _ret, const tars::PatchInfo &tPatchInfo, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tPatchInfo, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getPatchPercent", _os, _context);
            }
        }

        virtual tars::Int32 getProfileTemplate(const std::string & profileName,std::string &profileTemplate,std::string &resultDesc,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getProfileTemplate(std::string && profileName,std::string &profileTemplate,std::string &resultDesc,tars::TarsCurrentPtr _current_) 
        { return getProfileTemplate(profileName, profileTemplate, resultDesc, _current_); }
        static void async_response_getProfileTemplate(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &profileTemplate, const std::string &resultDesc)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("profileTemplate", profileTemplate);
                _tarsAttr_.put("resultDesc", resultDesc);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["profileTemplate"] = tars::JsonOutput::writeJson(profileTemplate);
                _p->value["resultDesc"] = tars::JsonOutput::writeJson(resultDesc);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(profileTemplate, 2);

                _os.write(resultDesc, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getProfileTemplate(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &profileTemplate, const std::string &resultDesc, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(profileTemplate, 2);

                _os.write(resultDesc, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getProfileTemplate", _os, _context);
            }
        }

        virtual tars::Int32 getServerNameList(const vector<tars::ApplicationServerName> & fullServerName,vector<map<std::string, std::string> > &serverList,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getServerNameList(vector<tars::ApplicationServerName> && fullServerName,vector<map<std::string, std::string> > &serverList,tars::TarsCurrentPtr _current_) 
        { return getServerNameList(fullServerName, serverList, _current_); }
        static void async_response_getServerNameList(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<map<std::string, std::string> > &serverList)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("serverList", serverList);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["serverList"] = tars::JsonOutput::writeJson(serverList);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(serverList, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getServerNameList(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<map<std::string, std::string> > &serverList, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(serverList, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getServerNameList", _os, _context);
            }
        }

        virtual tars::Int32 getServerProfileTemplate(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &profileTemplate,std::string &resultDesc,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getServerProfileTemplate(std::string && application,std::string && serverName,std::string && nodeName,std::string &profileTemplate,std::string &resultDesc,tars::TarsCurrentPtr _current_) 
        { return getServerProfileTemplate(application, serverName, nodeName, profileTemplate, resultDesc, _current_); }
        static void async_response_getServerProfileTemplate(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &profileTemplate, const std::string &resultDesc)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("profileTemplate", profileTemplate);
                _tarsAttr_.put("resultDesc", resultDesc);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["profileTemplate"] = tars::JsonOutput::writeJson(profileTemplate);
                _p->value["resultDesc"] = tars::JsonOutput::writeJson(resultDesc);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(profileTemplate, 4);

                _os.write(resultDesc, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getServerProfileTemplate(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &profileTemplate, const std::string &resultDesc, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(profileTemplate, 4);

                _os.write(resultDesc, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getServerProfileTemplate", _os, _context);
            }
        }

        virtual tars::Int32 getServerState(const std::string & application,const std::string & serverName,const std::string & nodeName,tars::ServerStateDesc &state,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getServerState(std::string && application,std::string && serverName,std::string && nodeName,tars::ServerStateDesc &state,std::string &result,tars::TarsCurrentPtr _current_) 
        { return getServerState(application, serverName, nodeName, state, result, _current_); }
        static void async_response_getServerState(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const tars::ServerStateDesc &state, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("state", state);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["state"] = tars::JsonOutput::writeJson(state);
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(state, 4);

                _os.write(result, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getServerState(tars::CurrentPtr _current_, tars::Int32 _ret, const tars::ServerStateDesc &state, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(state, 4);

                _os.write(result, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getServerState", _os, _context);
            }
        }

        virtual tars::Int32 getServerTree(vector<tars::ServerTree> &tree,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getServerTree(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<tars::ServerTree> &tree)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("tree", tree);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tree"] = tars::JsonOutput::writeJson(tree);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tree, 1);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getServerTree(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<tars::ServerTree> &tree, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tree, 1);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getServerTree", _os, _context);
            }
        }

        virtual tars::Int32 getServers(vector<tars::FrameworkServer> &servers,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getServers(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<tars::FrameworkServer> &servers)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("servers", servers);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["servers"] = tars::JsonOutput::writeJson(servers);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(servers, 1);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getServers(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<tars::FrameworkServer> &servers, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(servers, 1);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getServers", _os, _context);
            }
        }

        virtual tars::Int32 getTaskHistory(const std::string & application,const std::string & serverName,const std::string & command,vector<tars::TaskRsp> &taskRsps,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getTaskHistory(std::string && application,std::string && serverName,std::string && command,vector<tars::TaskRsp> &taskRsps,tars::TarsCurrentPtr _current_) 
        { return getTaskHistory(application, serverName, command, taskRsps, _current_); }
        static void async_response_getTaskHistory(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<tars::TaskRsp> &taskRsps)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("taskRsps", taskRsps);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["taskRsps"] = tars::JsonOutput::writeJson(taskRsps);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(taskRsps, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getTaskHistory(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<tars::TaskRsp> &taskRsps, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(taskRsps, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getTaskHistory", _os, _context);
            }
        }

        virtual tars::Int32 getTaskRsp(const std::string & taskNo,tars::TaskRsp &taskRsp,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getTaskRsp(std::string && taskNo,tars::TaskRsp &taskRsp,tars::TarsCurrentPtr _current_) 
        { return getTaskRsp(taskNo, taskRsp, _current_); }
        static void async_response_getTaskRsp(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const tars::TaskRsp &taskRsp)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("taskRsp", taskRsp);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["taskRsp"] = tars::JsonOutput::writeJson(taskRsp);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(taskRsp, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getTaskRsp(tars::CurrentPtr _current_, tars::Int32 _ret, const tars::TaskRsp &taskRsp, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(taskRsp, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getTaskRsp", _os, _context);
            }
        }

        virtual tars::Int32 getVersion(std::string &version,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getVersion(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &version)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("version", version);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["version"] = tars::JsonOutput::writeJson(version);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(version, 1);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getVersion(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &version, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(version, 1);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getVersion", _os, _context);
            }
        }

        virtual tars::Int32 hasAdminAuth(const std::string & uid,tars::Bool &has,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 hasAdminAuth(std::string && uid,tars::Bool &has,tars::TarsCurrentPtr _current_) 
        { return hasAdminAuth(uid, has, _current_); }
        static void async_response_hasAdminAuth(tars::TarsCurrentPtr _current_, tars::Int32 _ret, tars::Bool has)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("has", has);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["has"] = tars::JsonOutput::writeJson(has);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(has, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_hasAdminAuth(tars::CurrentPtr _current_, tars::Int32 _ret, tars::Bool has, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(has, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"hasAdminAuth", _os, _context);
            }
        }

        virtual tars::Int32 hasDevAuth(const std::string & application,const std::string & serverName,const std::string & uid,tars::Bool &has,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 hasDevAuth(std::string && application,std::string && serverName,std::string && uid,tars::Bool &has,tars::TarsCurrentPtr _current_) 
        { return hasDevAuth(application, serverName, uid, has, _current_); }
        static void async_response_hasDevAuth(tars::TarsCurrentPtr _current_, tars::Int32 _ret, tars::Bool has)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("has", has);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["has"] = tars::JsonOutput::writeJson(has);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(has, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_hasDevAuth(tars::CurrentPtr _current_, tars::Int32 _ret, tars::Bool has, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(has, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"hasDevAuth", _os, _context);
            }
        }

        virtual tars::Int32 hasOpeAuth(const std::string & application,const std::string & serverName,const std::string & uid,tars::Bool &has,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 hasOpeAuth(std::string && application,std::string && serverName,std::string && uid,tars::Bool &has,tars::TarsCurrentPtr _current_) 
        { return hasOpeAuth(application, serverName, uid, has, _current_); }
        static void async_response_hasOpeAuth(tars::TarsCurrentPtr _current_, tars::Int32 _ret, tars::Bool has)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("has", has);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["has"] = tars::JsonOutput::writeJson(has);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(has, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_hasOpeAuth(tars::CurrentPtr _current_, tars::Int32 _ret, tars::Bool has, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(has, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"hasOpeAuth", _os, _context);
            }
        }

        virtual tars::Int32 hasServer(const std::string & application,const std::string & serverName,tars::Bool &has,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 hasServer(std::string && application,std::string && serverName,tars::Bool &has,tars::TarsCurrentPtr _current_) 
        { return hasServer(application, serverName, has, _current_); }
        static void async_response_hasServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, tars::Bool has)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("has", has);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["has"] = tars::JsonOutput::writeJson(has);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(has, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_hasServer(tars::CurrentPtr _current_, tars::Int32 _ret, tars::Bool has, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(has, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"hasServer", _os, _context);
            }
        }

        virtual tars::Int32 insertAdapterConf(const std::string & sApplication,const std::string & serverName,const std::string & nodeName,const tars::AdapterConf & conf,tars::Bool replace,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 insertAdapterConf(std::string && sApplication,std::string && serverName,std::string && nodeName,tars::AdapterConf && conf,tars::Bool replace,tars::TarsCurrentPtr _current_) 
        { return insertAdapterConf(sApplication, serverName, nodeName, conf, replace, _current_); }
        static void async_response_insertAdapterConf(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_insertAdapterConf(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"insertAdapterConf", _os, _context);
            }
        }

        virtual tars::Int32 insertConfigFile(const std::string & sFullServerName,const std::string & fileName,const std::string & content,const std::string & nodeName,tars::Int32 level,tars::Bool replace,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 insertConfigFile(std::string && sFullServerName,std::string && fileName,std::string && content,std::string && nodeName,tars::Int32 level,tars::Bool replace,tars::TarsCurrentPtr _current_) 
        { return insertConfigFile(sFullServerName, fileName, content, nodeName, level, replace, _current_); }
        static void async_response_insertConfigFile(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_insertConfigFile(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"insertConfigFile", _os, _context);
            }
        }

        virtual tars::Int32 insertHistoryConfigFile(tars::Int32 configId,const std::string & reason,const std::string & content,tars::Bool replace,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 insertHistoryConfigFile(tars::Int32 configId,std::string && reason,std::string && content,tars::Bool replace,tars::TarsCurrentPtr _current_) 
        { return insertHistoryConfigFile(configId, reason, content, replace, _current_); }
        static void async_response_insertHistoryConfigFile(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_insertHistoryConfigFile(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"insertHistoryConfigFile", _os, _context);
            }
        }

        virtual tars::Int32 insertServerConf(const tars::ServerConf & conf,tars::Bool replace,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 insertServerConf(tars::ServerConf && conf,tars::Bool replace,tars::TarsCurrentPtr _current_) 
        { return insertServerConf(conf, replace, _current_); }
        static void async_response_insertServerConf(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_insertServerConf(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"insertServerConf", _os, _context);
            }
        }

        virtual tars::Int32 loadServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 loadServer(std::string && application,std::string && serverName,std::string && nodeName,std::string &result,tars::TarsCurrentPtr _current_) 
        { return loadServer(application, serverName, nodeName, result, _current_); }
        static void async_response_loadServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_loadServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"loadServer", _os, _context);
            }
        }

        virtual tars::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & command,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 notifyServer(std::string && application,std::string && serverName,std::string && nodeName,std::string && command,std::string &result,tars::TarsCurrentPtr _current_) 
        { return notifyServer(application, serverName, nodeName, command, result, _current_); }
        static void async_response_notifyServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_notifyServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"notifyServer", _os, _context);
            }
        }

        virtual tars::Bool pingNode(const std::string & name,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool pingNode(std::string && name,std::string &result,tars::TarsCurrentPtr _current_) 
        { return pingNode(name, result, _current_); }
        static void async_response_pingNode(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_pingNode(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"pingNode", _os, _context);
            }
        }

        virtual tars::Int32 registerPlugin(const tars::PluginConf & conf,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 registerPlugin(tars::PluginConf && conf,tars::TarsCurrentPtr _current_) 
        { return registerPlugin(conf, _current_); }
        static void async_response_registerPlugin(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_registerPlugin(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"registerPlugin", _os, _context);
            }
        }

        virtual tars::Int32 reportNode(const tars::ReportNode & rn,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 reportNode(tars::ReportNode && rn,tars::TarsCurrentPtr _current_) 
        { return reportNode(rn, _current_); }
        static void async_response_reportNode(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_reportNode(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"reportNode", _os, _context);
            }
        }

        virtual tars::Int32 reportResult(tars::Int32 requestId,const std::string & funcName,tars::Int32 ret,const std::string & result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 reportResult(tars::Int32 requestId,std::string && funcName,tars::Int32 ret,std::string && result,tars::TarsCurrentPtr _current_) 
        { return reportResult(requestId, funcName, ret, result, _current_); }
        static void async_response_reportResult(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_reportResult(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"reportResult", _os, _context);
            }
        }

        virtual tars::Int32 restartServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 restartServer(std::string && application,std::string && serverName,std::string && nodeName,std::string &result,tars::TarsCurrentPtr _current_) 
        { return restartServer(application, serverName, nodeName, result, _current_); }
        static void async_response_restartServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_restartServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"restartServer", _os, _context);
            }
        }

        virtual tars::Int32 setTaskItemInfo(const std::string & itemNo,const map<std::string, std::string> & info,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 setTaskItemInfo(std::string && itemNo,map<std::string, std::string> && info,tars::TarsCurrentPtr _current_) 
        { return setTaskItemInfo(itemNo, info, _current_); }
        static void async_response_setTaskItemInfo(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_setTaskItemInfo(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"setTaskItemInfo", _os, _context);
            }
        }

        virtual tars::Int32 shutdownNode(const std::string & name,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 shutdownNode(std::string && name,std::string &result,tars::TarsCurrentPtr _current_) 
        { return shutdownNode(name, result, _current_); }
        static void async_response_shutdownNode(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_shutdownNode(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"shutdownNode", _os, _context);
            }
        }

        virtual tars::Int32 startServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 startServer(std::string && application,std::string && serverName,std::string && nodeName,std::string &result,tars::TarsCurrentPtr _current_) 
        { return startServer(application, serverName, nodeName, result, _current_); }
        static void async_response_startServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_startServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"startServer", _os, _context);
            }
        }

        virtual tars::Int32 stopServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 stopServer(std::string && application,std::string && serverName,std::string && nodeName,std::string &result,tars::TarsCurrentPtr _current_) 
        { return stopServer(application, serverName, nodeName, result, _current_); }
        static void async_response_stopServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_stopServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"stopServer", _os, _context);
            }
        }

        virtual tars::Int32 undeploy(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & user,std::string &log,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 undeploy(std::string && application,std::string && serverName,std::string && nodeName,std::string && user,std::string &log,tars::TarsCurrentPtr _current_) 
        { return undeploy(application, serverName, nodeName, user, log, _current_); }
        static void async_response_undeploy(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &log)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("log", log);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["log"] = tars::JsonOutput::writeJson(log);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(log, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_undeploy(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &log, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(log, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"undeploy", _os, _context);
            }
        }

        virtual tars::Int32 uninstallServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 uninstallServer(std::string && application,std::string && serverName,std::string && nodeName,std::string &result,tars::TarsCurrentPtr _current_) 
        { return uninstallServer(application, serverName, nodeName, result, _current_); }
        static void async_response_uninstallServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_uninstallServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"uninstallServer", _os, _context);
            }
        }

        virtual tars::Int32 updatePatchLog(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & patchId,const std::string & user,const std::string & patchType,tars::Bool succ,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 updatePatchLog(std::string && application,std::string && serverName,std::string && nodeName,std::string && patchId,std::string && user,std::string && patchType,tars::Bool succ,tars::TarsCurrentPtr _current_) 
        { return updatePatchLog(application, serverName, nodeName, patchId, user, patchType, succ, _current_); }
        static void async_response_updatePatchLog(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_updatePatchLog(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"updatePatchLog", _os, _context);
            }
        }

        virtual tars::Int32 updateServerFlowState(const std::string & application,const std::string & serverName,const vector<std::string> & nodeList,tars::Bool bActive,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 updateServerFlowState(std::string && application,std::string && serverName,vector<std::string> && nodeList,tars::Bool bActive,tars::TarsCurrentPtr _current_) 
        { return updateServerFlowState(application, serverName, nodeList, bActive, _current_); }
        static void async_response_updateServerFlowState(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_updateServerFlowState(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"updateServerFlowState", _os, _context);
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __tars__AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "checkDockerRegistry",
                "checkServer",
                "checkTicket",
                "delCache",
                "deleteNode",
                "deletePatchFile",
                "destroyServer",
                "dockerPull",
                "forceDockerLogin",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getConfigFileId",
                "getGroupId",
                "getLogData",
                "getLogFileList",
                "getNodeList",
                "getNodeLoad",
                "getNodeVesion",
                "getPatchPackage",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerNameList",
                "getServerProfileTemplate",
                "getServerState",
                "getServerTree",
                "getServers",
                "getTaskHistory",
                "getTaskRsp",
                "getVersion",
                "hasAdminAuth",
                "hasDevAuth",
                "hasOpeAuth",
                "hasServer",
                "insertAdapterConf",
                "insertConfigFile",
                "insertHistoryConfigFile",
                "insertServerConf",
                "loadServer",
                "notifyServer",
                "pingNode",
                "registerPlugin",
                "reportNode",
                "reportResult",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "uninstallServer",
                "updatePatchLog",
                "updateServerFlowState"
            };

            pair<string*, string*> r = equal_range(__tars__AdminReg_all, __tars__AdminReg_all+56, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __tars__AdminReg_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::TaskReq taskReq;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("taskReq", taskReq);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(taskReq, _jsonPtr->value["taskReq"], true);
                    }
                    else
                    {
                        _is.read(taskReq, 1, true);
                    }
                    tars::Int32 _ret = addTaskReq(std::move(taskReq), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::PatchRequest req;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("req", req);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(result, 2, false);
                    }
                    tars::Int32 _ret = batchPatch(std::move(req),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string registry;
                    std::string userName;
                    std::string password;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("registry", registry);
                        _tarsAttr_.get("userName", userName);
                        _tarsAttr_.get("password", password);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(registry, _jsonPtr->value["registry"], true);
                        tars::JsonInput::readJson(userName, _jsonPtr->value["userName"], true);
                        tars::JsonInput::readJson(password, _jsonPtr->value["password"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(registry, 1, true);
                        _is.read(userName, 2, true);
                        _is.read(password, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = checkDockerRegistry(std::move(registry),std::move(userName),std::move(password),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::FrameworkServer server;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("server", server);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(server, _jsonPtr->value["server"], true);
                    }
                    else
                    {
                        _is.read(server, 1, true);
                    }
                    tars::Int32 _ret = checkServer(std::move(server), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string ticket;
                    std::string uid;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("ticket", ticket);
                        _tarsAttr_.getByDefault("uid", uid, uid);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(ticket, _jsonPtr->value["ticket"], true);
                        tars::JsonInput::readJson(uid, _jsonPtr->value["uid"], false);
                    }
                    else
                    {
                        _is.read(ticket, 1, true);
                        _is.read(uid, 2, false);
                    }
                    tars::Int32 _ret = checkTicket(std::move(ticket),uid, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("uid", uid);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["uid"] = tars::JsonOutput::writeJson(uid);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(uid, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string nodeName;
                    std::string sFullCacheName;
                    std::string sBackupPath;
                    std::string sKey;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.get("sFullCacheName", sFullCacheName);
                        _tarsAttr_.get("sBackupPath", sBackupPath);
                        _tarsAttr_.get("sKey", sKey);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(sFullCacheName, _jsonPtr->value["sFullCacheName"], true);
                        tars::JsonInput::readJson(sBackupPath, _jsonPtr->value["sBackupPath"], true);
                        tars::JsonInput::readJson(sKey, _jsonPtr->value["sKey"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(nodeName, 1, true);
                        _is.read(sFullCacheName, 2, true);
                        _is.read(sBackupPath, 3, true);
                        _is.read(sKey, 4, true);
                        _is.read(result, 5, false);
                    }
                    tars::Int32 _ret = delCache(std::move(nodeName),std::move(sFullCacheName),std::move(sBackupPath),std::move(sKey),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::ReportNode rn;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("rn", rn);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(rn, _jsonPtr->value["rn"], true);
                    }
                    else
                    {
                        _is.read(rn, 1, true);
                    }
                    tars::Int32 _ret = deleteNode(std::move(rn), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string patchFile;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("patchFile", patchFile);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(patchFile, _jsonPtr->value["patchFile"], true);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(patchFile, 3, true);
                    }
                    tars::Int32 _ret = deletePatchFile(std::move(application),std::move(serverName),std::move(patchFile), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = destroyServer(std::move(application),std::move(serverName),std::move(nodeName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string baseImageId;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("baseImageId", baseImageId);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(baseImageId, _jsonPtr->value["baseImageId"], true);
                    }
                    else
                    {
                        _is.read(baseImageId, 1, true);
                    }
                    tars::Int32 _ret = dockerPull(std::move(baseImageId), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string nodeName;
                    vector<std::string> result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(nodeName, 1, true);
                        _is.read(result, 2, false);
                    }
                    tars::Int32 _ret = forceDockerLogin(std::move(nodeName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    vector<std::string> _ret = getAllApplicationNames(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    vector<std::string> _ret = getAllNodeNames(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    vector<vector<std::string> > _ret = getAllServerIds(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sClientIp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("sClientIp", sClientIp, sClientIp);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sClientIp, _jsonPtr->value["sClientIp"], false);
                    }
                    else
                    {
                        _is.read(sClientIp, 1, false);
                    }
                    tars::Int32 _ret = getClientIp(sClientIp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("sClientIp", sClientIp);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["sClientIp"] = tars::JsonOutput::writeJson(sClientIp);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(sClientIp, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sFullServerName;
                    std::string fileName;
                    std::string nodeName;
                    tars::Int32 level;
                    tars::Int32 configId;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sFullServerName", sFullServerName);
                        _tarsAttr_.get("fileName", fileName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.get("level", level);
                        _tarsAttr_.getByDefault("configId", configId, configId);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sFullServerName, _jsonPtr->value["sFullServerName"], true);
                        tars::JsonInput::readJson(fileName, _jsonPtr->value["fileName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(level, _jsonPtr->value["level"], true);
                        tars::JsonInput::readJson(configId, _jsonPtr->value["configId"], false);
                    }
                    else
                    {
                        _is.read(sFullServerName, 1, true);
                        _is.read(fileName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(level, 4, true);
                        _is.read(configId, 5, false);
                    }
                    tars::Int32 _ret = getConfigFileId(std::move(sFullServerName),std::move(fileName),std::move(nodeName),level,configId, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("configId", configId);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["configId"] = tars::JsonOutput::writeJson(configId);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(configId, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string ip;
                    tars::Int32 groupId;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("ip", ip);
                        _tarsAttr_.getByDefault("groupId", groupId, groupId);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(ip, _jsonPtr->value["ip"], true);
                        tars::JsonInput::readJson(groupId, _jsonPtr->value["groupId"], false);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(ip, 1, true);
                        _is.read(groupId, 2, false);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = getGroupId(std::move(ip),groupId,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("groupId", groupId);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["groupId"] = tars::JsonOutput::writeJson(groupId);
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(groupId, 2);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string logFile;
                    std::string cmd;
                    std::string fileData;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.get("logFile", logFile);
                        _tarsAttr_.get("cmd", cmd);
                        _tarsAttr_.getByDefault("fileData", fileData, fileData);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(logFile, _jsonPtr->value["logFile"], true);
                        tars::JsonInput::readJson(cmd, _jsonPtr->value["cmd"], true);
                        tars::JsonInput::readJson(fileData, _jsonPtr->value["fileData"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(logFile, 4, true);
                        _is.read(cmd, 5, true);
                        _is.read(fileData, 6, false);
                    }
                    tars::Int32 _ret = getLogData(std::move(application),std::move(serverName),std::move(nodeName),std::move(logFile),std::move(cmd),fileData, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("fileData", fileData);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["fileData"] = tars::JsonOutput::writeJson(fileData);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(fileData, 6);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    vector<std::string> logFileList;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("logFileList", logFileList, logFileList);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(logFileList, _jsonPtr->value["logFileList"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(logFileList, 4, false);
                    }
                    tars::Int32 _ret = getLogFileList(std::move(application),std::move(serverName),std::move(nodeName),logFileList, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("logFileList", logFileList);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["logFileList"] = tars::JsonOutput::writeJson(logFileList);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(logFileList, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    vector<std::string> nodeNames;
                    map<std::string, std::string> heartbeats;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("nodeNames", nodeNames);
                        _tarsAttr_.getByDefault("heartbeats", heartbeats, heartbeats);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(nodeNames, _jsonPtr->value["nodeNames"], true);
                        tars::JsonInput::readJson(heartbeats, _jsonPtr->value["heartbeats"], false);
                    }
                    else
                    {
                        _is.read(nodeNames, 1, true);
                        _is.read(heartbeats, 2, false);
                    }
                    tars::Int32 _ret = getNodeList(std::move(nodeNames),heartbeats, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("heartbeats", heartbeats);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["heartbeats"] = tars::JsonOutput::writeJson(heartbeats);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(heartbeats, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    tars::Int32 pid;
                    std::string fileData;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.get("pid", pid);
                        _tarsAttr_.getByDefault("fileData", fileData, fileData);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(pid, _jsonPtr->value["pid"], true);
                        tars::JsonInput::readJson(fileData, _jsonPtr->value["fileData"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(pid, 4, true);
                        _is.read(fileData, 5, false);
                    }
                    tars::Int32 _ret = getNodeLoad(std::move(application),std::move(serverName),std::move(nodeName),pid,fileData, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("fileData", fileData);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["fileData"] = tars::JsonOutput::writeJson(fileData);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(fileData, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 21:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string name;
                    std::string version;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("name", name);
                        _tarsAttr_.getByDefault("version", version, version);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(name, _jsonPtr->value["name"], true);
                        tars::JsonInput::readJson(version, _jsonPtr->value["version"], false);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(name, 1, true);
                        _is.read(version, 2, false);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = getNodeVesion(std::move(name),version,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("version", version);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["version"] = tars::JsonOutput::writeJson(version);
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(version, 2);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 22:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    tars::Int32 packageType;
                    tars::Int32 defaultVersion;
                    tars::PatchPackage pack;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("packageType", packageType);
                        _tarsAttr_.get("defaultVersion", defaultVersion);
                        _tarsAttr_.getByDefault("pack", pack, pack);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(packageType, _jsonPtr->value["packageType"], true);
                        tars::JsonInput::readJson(defaultVersion, _jsonPtr->value["defaultVersion"], true);
                        tars::JsonInput::readJson(pack, _jsonPtr->value["pack"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(packageType, 3, true);
                        _is.read(defaultVersion, 4, true);
                        _is.read(pack, 5, false);
                    }
                    tars::Int32 _ret = getPatchPackage(std::move(application),std::move(serverName),packageType,defaultVersion,pack, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pack", pack);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pack"] = tars::JsonOutput::writeJson(pack);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pack, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 23:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    tars::PatchInfo tPatchInfo;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("tPatchInfo", tPatchInfo, tPatchInfo);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(tPatchInfo, _jsonPtr->value["tPatchInfo"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(tPatchInfo, 4, false);
                    }
                    tars::Int32 _ret = getPatchPercent(std::move(application),std::move(serverName),std::move(nodeName),tPatchInfo, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("tPatchInfo", tPatchInfo);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tPatchInfo"] = tars::JsonOutput::writeJson(tPatchInfo);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(tPatchInfo, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 24:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string profileName;
                    std::string profileTemplate;
                    std::string resultDesc;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("profileName", profileName);
                        _tarsAttr_.getByDefault("profileTemplate", profileTemplate, profileTemplate);
                        _tarsAttr_.getByDefault("resultDesc", resultDesc, resultDesc);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(profileName, _jsonPtr->value["profileName"], true);
                        tars::JsonInput::readJson(profileTemplate, _jsonPtr->value["profileTemplate"], false);
                        tars::JsonInput::readJson(resultDesc, _jsonPtr->value["resultDesc"], false);
                    }
                    else
                    {
                        _is.read(profileName, 1, true);
                        _is.read(profileTemplate, 2, false);
                        _is.read(resultDesc, 3, false);
                    }
                    tars::Int32 _ret = getProfileTemplate(std::move(profileName),profileTemplate,resultDesc, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("profileTemplate", profileTemplate);
                            _tarsAttr_.put("resultDesc", resultDesc);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["profileTemplate"] = tars::JsonOutput::writeJson(profileTemplate);
                            _p->value["resultDesc"] = tars::JsonOutput::writeJson(resultDesc);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(profileTemplate, 2);
                            _os.write(resultDesc, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 25:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    vector<tars::ApplicationServerName> fullServerName;
                    vector<map<std::string, std::string> > serverList;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("fullServerName", fullServerName);
                        _tarsAttr_.getByDefault("serverList", serverList, serverList);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(fullServerName, _jsonPtr->value["fullServerName"], true);
                        tars::JsonInput::readJson(serverList, _jsonPtr->value["serverList"], false);
                    }
                    else
                    {
                        _is.read(fullServerName, 1, true);
                        _is.read(serverList, 2, false);
                    }
                    tars::Int32 _ret = getServerNameList(std::move(fullServerName),serverList, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("serverList", serverList);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["serverList"] = tars::JsonOutput::writeJson(serverList);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(serverList, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 26:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string profileTemplate;
                    std::string resultDesc;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("profileTemplate", profileTemplate, profileTemplate);
                        _tarsAttr_.getByDefault("resultDesc", resultDesc, resultDesc);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(profileTemplate, _jsonPtr->value["profileTemplate"], false);
                        tars::JsonInput::readJson(resultDesc, _jsonPtr->value["resultDesc"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(profileTemplate, 4, false);
                        _is.read(resultDesc, 5, false);
                    }
                    tars::Int32 _ret = getServerProfileTemplate(std::move(application),std::move(serverName),std::move(nodeName),profileTemplate,resultDesc, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("profileTemplate", profileTemplate);
                            _tarsAttr_.put("resultDesc", resultDesc);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["profileTemplate"] = tars::JsonOutput::writeJson(profileTemplate);
                            _p->value["resultDesc"] = tars::JsonOutput::writeJson(resultDesc);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(profileTemplate, 4);
                            _os.write(resultDesc, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 27:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    tars::ServerStateDesc state;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("state", state, state);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(state, _jsonPtr->value["state"], false);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(state, 4, false);
                        _is.read(result, 5, false);
                    }
                    tars::Int32 _ret = getServerState(std::move(application),std::move(serverName),std::move(nodeName),state,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("state", state);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["state"] = tars::JsonOutput::writeJson(state);
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(state, 4);
                            _os.write(result, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 28:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    vector<tars::ServerTree> tree;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("tree", tree, tree);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tree, _jsonPtr->value["tree"], false);
                    }
                    else
                    {
                        _is.read(tree, 1, false);
                    }
                    tars::Int32 _ret = getServerTree(tree, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("tree", tree);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tree"] = tars::JsonOutput::writeJson(tree);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(tree, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 29:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    vector<tars::FrameworkServer> servers;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("servers", servers, servers);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(servers, _jsonPtr->value["servers"], false);
                    }
                    else
                    {
                        _is.read(servers, 1, false);
                    }
                    tars::Int32 _ret = getServers(servers, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("servers", servers);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["servers"] = tars::JsonOutput::writeJson(servers);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(servers, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 30:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string command;
                    vector<tars::TaskRsp> taskRsps;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("command", command);
                        _tarsAttr_.getByDefault("taskRsps", taskRsps, taskRsps);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(command, _jsonPtr->value["command"], true);
                        tars::JsonInput::readJson(taskRsps, _jsonPtr->value["taskRsps"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(command, 3, true);
                        _is.read(taskRsps, 4, false);
                    }
                    tars::Int32 _ret = getTaskHistory(std::move(application),std::move(serverName),std::move(command),taskRsps, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("taskRsps", taskRsps);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["taskRsps"] = tars::JsonOutput::writeJson(taskRsps);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(taskRsps, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 31:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string taskNo;
                    tars::TaskRsp taskRsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("taskNo", taskNo);
                        _tarsAttr_.getByDefault("taskRsp", taskRsp, taskRsp);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(taskNo, _jsonPtr->value["taskNo"], true);
                        tars::JsonInput::readJson(taskRsp, _jsonPtr->value["taskRsp"], false);
                    }
                    else
                    {
                        _is.read(taskNo, 1, true);
                        _is.read(taskRsp, 2, false);
                    }
                    tars::Int32 _ret = getTaskRsp(std::move(taskNo),taskRsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("taskRsp", taskRsp);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["taskRsp"] = tars::JsonOutput::writeJson(taskRsp);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(taskRsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 32:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string version;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("version", version, version);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(version, _jsonPtr->value["version"], false);
                    }
                    else
                    {
                        _is.read(version, 1, false);
                    }
                    tars::Int32 _ret = getVersion(version, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("version", version);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["version"] = tars::JsonOutput::writeJson(version);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(version, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 33:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string uid;
                    tars::Bool has = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("uid", uid);
                        _tarsAttr_.getByDefault("has", has, has);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(uid, _jsonPtr->value["uid"], true);
                        tars::JsonInput::readJson(has, _jsonPtr->value["has"], false);
                    }
                    else
                    {
                        _is.read(uid, 1, true);
                        _is.read(has, 2, false);
                    }
                    tars::Int32 _ret = hasAdminAuth(std::move(uid),has, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("has", has);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["has"] = tars::JsonOutput::writeJson(has);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(has, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 34:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string uid;
                    tars::Bool has = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("uid", uid);
                        _tarsAttr_.getByDefault("has", has, has);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(uid, _jsonPtr->value["uid"], true);
                        tars::JsonInput::readJson(has, _jsonPtr->value["has"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(uid, 3, true);
                        _is.read(has, 4, false);
                    }
                    tars::Int32 _ret = hasDevAuth(std::move(application),std::move(serverName),std::move(uid),has, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("has", has);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["has"] = tars::JsonOutput::writeJson(has);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(has, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 35:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string uid;
                    tars::Bool has = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("uid", uid);
                        _tarsAttr_.getByDefault("has", has, has);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(uid, _jsonPtr->value["uid"], true);
                        tars::JsonInput::readJson(has, _jsonPtr->value["has"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(uid, 3, true);
                        _is.read(has, 4, false);
                    }
                    tars::Int32 _ret = hasOpeAuth(std::move(application),std::move(serverName),std::move(uid),has, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("has", has);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["has"] = tars::JsonOutput::writeJson(has);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(has, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 36:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    tars::Bool has = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.getByDefault("has", has, has);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(has, _jsonPtr->value["has"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(has, 3, false);
                    }
                    tars::Int32 _ret = hasServer(std::move(application),std::move(serverName),has, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("has", has);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["has"] = tars::JsonOutput::writeJson(has);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(has, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 37:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sApplication;
                    std::string serverName;
                    std::string nodeName;
                    tars::AdapterConf conf;
                    tars::Bool replace = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sApplication", sApplication);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.get("conf", conf);
                        _tarsAttr_.get("replace", replace);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sApplication, _jsonPtr->value["sApplication"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(conf, _jsonPtr->value["conf"], true);
                        tars::JsonInput::readJson(replace, _jsonPtr->value["replace"], true);
                    }
                    else
                    {
                        _is.read(sApplication, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(conf, 4, true);
                        _is.read(replace, 5, true);
                    }
                    tars::Int32 _ret = insertAdapterConf(std::move(sApplication),std::move(serverName),std::move(nodeName),std::move(conf),replace, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 38:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sFullServerName;
                    std::string fileName;
                    std::string content;
                    std::string nodeName;
                    tars::Int32 level;
                    tars::Bool replace = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sFullServerName", sFullServerName);
                        _tarsAttr_.get("fileName", fileName);
                        _tarsAttr_.get("content", content);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.get("level", level);
                        _tarsAttr_.get("replace", replace);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sFullServerName, _jsonPtr->value["sFullServerName"], true);
                        tars::JsonInput::readJson(fileName, _jsonPtr->value["fileName"], true);
                        tars::JsonInput::readJson(content, _jsonPtr->value["content"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(level, _jsonPtr->value["level"], true);
                        tars::JsonInput::readJson(replace, _jsonPtr->value["replace"], true);
                    }
                    else
                    {
                        _is.read(sFullServerName, 1, true);
                        _is.read(fileName, 2, true);
                        _is.read(content, 3, true);
                        _is.read(nodeName, 4, true);
                        _is.read(level, 5, true);
                        _is.read(replace, 6, true);
                    }
                    tars::Int32 _ret = insertConfigFile(std::move(sFullServerName),std::move(fileName),std::move(content),std::move(nodeName),level,replace, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 39:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 configId;
                    std::string reason;
                    std::string content;
                    tars::Bool replace = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("configId", configId);
                        _tarsAttr_.get("reason", reason);
                        _tarsAttr_.get("content", content);
                        _tarsAttr_.get("replace", replace);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(configId, _jsonPtr->value["configId"], true);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], true);
                        tars::JsonInput::readJson(content, _jsonPtr->value["content"], true);
                        tars::JsonInput::readJson(replace, _jsonPtr->value["replace"], true);
                    }
                    else
                    {
                        _is.read(configId, 1, true);
                        _is.read(reason, 2, true);
                        _is.read(content, 3, true);
                        _is.read(replace, 4, true);
                    }
                    tars::Int32 _ret = insertHistoryConfigFile(configId,std::move(reason),std::move(content),replace, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 40:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::ServerConf conf;
                    tars::Bool replace = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("conf", conf);
                        _tarsAttr_.get("replace", replace);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(conf, _jsonPtr->value["conf"], true);
                        tars::JsonInput::readJson(replace, _jsonPtr->value["replace"], true);
                    }
                    else
                    {
                        _is.read(conf, 1, true);
                        _is.read(replace, 2, true);
                    }
                    tars::Int32 _ret = insertServerConf(std::move(conf),replace, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 41:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = loadServer(std::move(application),std::move(serverName),std::move(nodeName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 42:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string command;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.get("command", command);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(command, _jsonPtr->value["command"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(command, 4, true);
                        _is.read(result, 5, false);
                    }
                    tars::Int32 _ret = notifyServer(std::move(application),std::move(serverName),std::move(nodeName),std::move(command),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 43:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string name;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("name", name);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(name, _jsonPtr->value["name"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(name, 1, true);
                        _is.read(result, 2, false);
                    }
                    tars::Bool _ret = pingNode(std::move(name),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 44:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::PluginConf conf;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("conf", conf);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(conf, _jsonPtr->value["conf"], true);
                    }
                    else
                    {
                        _is.read(conf, 1, true);
                    }
                    tars::Int32 _ret = registerPlugin(std::move(conf), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 45:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::ReportNode rn;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("rn", rn);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(rn, _jsonPtr->value["rn"], true);
                    }
                    else
                    {
                        _is.read(rn, 1, true);
                    }
                    tars::Int32 _ret = reportNode(std::move(rn), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 46:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string funcName;
                    tars::Int32 ret;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("requestId", requestId);
                        _tarsAttr_.get("funcName", funcName);
                        _tarsAttr_.get("ret", ret);
                        _tarsAttr_.get("result", result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], true);
                        tars::JsonInput::readJson(funcName, _jsonPtr->value["funcName"], true);
                        tars::JsonInput::readJson(ret, _jsonPtr->value["ret"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], true);
                    }
                    else
                    {
                        _is.read(requestId, 1, true);
                        _is.read(funcName, 2, true);
                        _is.read(ret, 3, true);
                        _is.read(result, 4, true);
                    }
                    tars::Int32 _ret = reportResult(requestId,std::move(funcName),ret,std::move(result), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 47:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = restartServer(std::move(application),std::move(serverName),std::move(nodeName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 48:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string itemNo;
                    map<std::string, std::string> info;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("itemNo", itemNo);
                        _tarsAttr_.get("info", info);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(itemNo, _jsonPtr->value["itemNo"], true);
                        tars::JsonInput::readJson(info, _jsonPtr->value["info"], true);
                    }
                    else
                    {
                        _is.read(itemNo, 1, true);
                        _is.read(info, 2, true);
                    }
                    tars::Int32 _ret = setTaskItemInfo(std::move(itemNo),std::move(info), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 49:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string name;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("name", name);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(name, _jsonPtr->value["name"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(name, 1, true);
                        _is.read(result, 2, false);
                    }
                    tars::Int32 _ret = shutdownNode(std::move(name),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 50:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = startServer(std::move(application),std::move(serverName),std::move(nodeName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 51:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = stopServer(std::move(application),std::move(serverName),std::move(nodeName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 52:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string user;
                    std::string log;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.get("user", user);
                        _tarsAttr_.getByDefault("log", log, log);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(user, _jsonPtr->value["user"], true);
                        tars::JsonInput::readJson(log, _jsonPtr->value["log"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(user, 4, true);
                        _is.read(log, 5, false);
                    }
                    tars::Int32 _ret = undeploy(std::move(application),std::move(serverName),std::move(nodeName),std::move(user),log, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("log", log);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["log"] = tars::JsonOutput::writeJson(log);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(log, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 53:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = uninstallServer(std::move(application),std::move(serverName),std::move(nodeName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 54:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string patchId;
                    std::string user;
                    std::string patchType;
                    tars::Bool succ = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeName", nodeName);
                        _tarsAttr_.get("patchId", patchId);
                        _tarsAttr_.get("user", user);
                        _tarsAttr_.get("patchType", patchType);
                        _tarsAttr_.get("succ", succ);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        tars::JsonInput::readJson(patchId, _jsonPtr->value["patchId"], true);
                        tars::JsonInput::readJson(user, _jsonPtr->value["user"], true);
                        tars::JsonInput::readJson(patchType, _jsonPtr->value["patchType"], true);
                        tars::JsonInput::readJson(succ, _jsonPtr->value["succ"], true);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(patchId, 4, true);
                        _is.read(user, 5, true);
                        _is.read(patchType, 6, true);
                        _is.read(succ, 7, true);
                    }
                    tars::Int32 _ret = updatePatchLog(std::move(application),std::move(serverName),std::move(nodeName),std::move(patchId),std::move(user),std::move(patchType),succ, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 55:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    vector<std::string> nodeList;
                    tars::Bool bActive = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("nodeList", nodeList);
                        _tarsAttr_.get("bActive", bActive);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(nodeList, _jsonPtr->value["nodeList"], true);
                        tars::JsonInput::readJson(bActive, _jsonPtr->value["bActive"], true);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeList, 3, true);
                        _is.read(bActive, 4, true);
                    }
                    tars::Int32 _ret = updateServerFlowState(std::move(application),std::move(serverName),std::move(nodeList),bActive, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
