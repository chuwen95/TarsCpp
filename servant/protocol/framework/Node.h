// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.13.
// **********************************************************************

#ifndef __NODE_H_
#define __NODE_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "NodeDescriptor.h"
#include "RegistryDescriptor.h"
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace tars
{

    /* callback of async proxy for client */
    class NodePrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~NodePrxCallback(){}
        virtual void callback_delCache(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_delCache() override incorrect."); }
        virtual void callback_delCache_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_delCache_exception() override incorrect."); }
        virtual void callback_delCache(tars::Int32 ret, std::string&&  result)
        { callback_delCache(ret, result); }

        virtual void callback_destroyServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_destroyServer() override incorrect."); }
        virtual void callback_destroyServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_destroyServer_exception() override incorrect."); }
        virtual void callback_destroyServer(tars::Int32 ret, std::string&&  result)
        { callback_destroyServer(ret, result); }

        virtual void callback_forceDockerLogin(tars::Int32 ret,  const vector<std::string>& result)
        { throw std::runtime_error("callback_forceDockerLogin() override incorrect."); }
        virtual void callback_forceDockerLogin_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_forceDockerLogin_exception() override incorrect."); }
        virtual void callback_forceDockerLogin(tars::Int32 ret, vector<std::string>&&  result)
        { callback_forceDockerLogin(ret, result); }

        virtual void callback_getLogData(tars::Int32 ret,  const std::string& fileData)
        { throw std::runtime_error("callback_getLogData() override incorrect."); }
        virtual void callback_getLogData_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getLogData_exception() override incorrect."); }
        virtual void callback_getLogData(tars::Int32 ret, std::string&&  fileData)
        { callback_getLogData(ret, fileData); }

        virtual void callback_getLogFileList(tars::Int32 ret,  const vector<std::string>& logFileList)
        { throw std::runtime_error("callback_getLogFileList() override incorrect."); }
        virtual void callback_getLogFileList_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getLogFileList_exception() override incorrect."); }
        virtual void callback_getLogFileList(tars::Int32 ret, vector<std::string>&&  logFileList)
        { callback_getLogFileList(ret, logFileList); }

        virtual void callback_getNodeLoad(tars::Int32 ret,  const std::string& fileData)
        { throw std::runtime_error("callback_getNodeLoad() override incorrect."); }
        virtual void callback_getNodeLoad_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getNodeLoad_exception() override incorrect."); }
        virtual void callback_getNodeLoad(tars::Int32 ret, std::string&&  fileData)
        { callback_getNodeLoad(ret, fileData); }

        virtual void callback_getPatchPercent(tars::Int32 ret,  const tars::PatchInfo& tPatchInfo)
        { throw std::runtime_error("callback_getPatchPercent() override incorrect."); }
        virtual void callback_getPatchPercent_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getPatchPercent_exception() override incorrect."); }
        virtual void callback_getPatchPercent(tars::Int32 ret, tars::PatchInfo&&  tPatchInfo)
        { callback_getPatchPercent(ret, tPatchInfo); }

        virtual void callback_getStateInfo(tars::Int32 ret,  const tars::ServerStateInfo& info,  const std::string& result)
        { throw std::runtime_error("callback_getStateInfo() override incorrect."); }
        virtual void callback_getStateInfo_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getStateInfo_exception() override incorrect."); }
        virtual void callback_getStateInfo(tars::Int32 ret, tars::ServerStateInfo&&  info, std::string&&  result)
        { callback_getStateInfo(ret, info, result); }

        virtual void callback_loadServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_loadServer() override incorrect."); }
        virtual void callback_loadServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_loadServer_exception() override incorrect."); }
        virtual void callback_loadServer(tars::Int32 ret, std::string&&  result)
        { callback_loadServer(ret, result); }

        virtual void callback_notifyServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_notifyServer() override incorrect."); }
        virtual void callback_notifyServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_notifyServer_exception() override incorrect."); }
        virtual void callback_notifyServer(tars::Int32 ret, std::string&&  result)
        { callback_notifyServer(ret, result); }

        virtual void callback_patchPro(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_patchPro() override incorrect."); }
        virtual void callback_patchPro_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_patchPro_exception() override incorrect."); }
        virtual void callback_patchPro(tars::Int32 ret, std::string&&  result)
        { callback_patchPro(ret, result); }

        virtual void callback_shutdown(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_shutdown() override incorrect."); }
        virtual void callback_shutdown_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_shutdown_exception() override incorrect."); }
        virtual void callback_shutdown(tars::Int32 ret, std::string&&  result)
        { callback_shutdown(ret, result); }

        virtual void callback_startServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_startServer() override incorrect."); }
        virtual void callback_startServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_startServer_exception() override incorrect."); }
        virtual void callback_startServer(tars::Int32 ret, std::string&&  result)
        { callback_startServer(ret, result); }

        virtual void callback_stopAllServers(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_stopAllServers() override incorrect."); }
        virtual void callback_stopAllServers_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_stopAllServers_exception() override incorrect."); }
        virtual void callback_stopAllServers(tars::Int32 ret, std::string&&  result)
        { callback_stopAllServers(ret, result); }

        virtual void callback_stopServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_stopServer() override incorrect."); }
        virtual void callback_stopServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_stopServer_exception() override incorrect."); }
        virtual void callback_stopServer(tars::Int32 ret, std::string&&  result)
        { callback_stopServer(ret, result); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __Node_all[]=
            {
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getPatchPercent",
                "getStateInfo",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer"
            };
            auto it = _msg_->response->status.find("TARS_FUNC");
            pair<string*, string*> r = equal_range(__Node_all, __Node_all+15, (it==_msg_->response->status.end())?_msg_->request.sFuncName:it->second);
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_delCache(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_destroyServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<std::string> result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_forceDockerLogin(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogData_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string fileData;
                    _is.read(fileData, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getLogData(_ret, std::move(fileData));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<std::string> logFileList;
                    _is.read(logFileList, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getLogFileList(_ret, std::move(logFileList));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string fileData;
                    _is.read(fileData, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getNodeLoad(_ret, std::move(fileData));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::PatchInfo tPatchInfo;
                    _is.read(tPatchInfo, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getPatchPercent(_ret, std::move(tPatchInfo));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::ServerStateInfo info;
                    _is.read(info, 3, true);
                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getStateInfo(_ret, std::move(info), std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_loadServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_notifyServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_patchPro_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_patchPro(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_shutdown(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_startServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopAllServers_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_stopAllServers(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_stopServer(_ret, std::move(result));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<NodePrxCallback> NodePrxCallbackPtr;

    //callback of promise async proxy for client
    class NodePrxCallbackPromise: public tars::ServantProxyCallback
    {
    public:
        virtual ~NodePrxCallbackPromise(){}
    public:
        struct PromisedelCache: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisedelCache > PromisedelCachePtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisedelCachePtr > &promise)
        : _promise_delCache(promise)
        {}
        
        virtual void callback_delCache(const NodePrxCallbackPromise::PromisedelCachePtr &ptr)
        {
            _promise_delCache.setValue(ptr);
        }
        virtual void callback_delCache_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:delCache_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_delCache.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisedelCachePtr > _promise_delCache;

    public:
        struct PromisedestroyServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisedestroyServer > PromisedestroyServerPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisedestroyServerPtr > &promise)
        : _promise_destroyServer(promise)
        {}
        
        virtual void callback_destroyServer(const NodePrxCallbackPromise::PromisedestroyServerPtr &ptr)
        {
            _promise_destroyServer.setValue(ptr);
        }
        virtual void callback_destroyServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:destroyServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_destroyServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisedestroyServerPtr > _promise_destroyServer;

    public:
        struct PromiseforceDockerLogin: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<std::string> result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromiseforceDockerLogin > PromiseforceDockerLoginPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromiseforceDockerLoginPtr > &promise)
        : _promise_forceDockerLogin(promise)
        {}
        
        virtual void callback_forceDockerLogin(const NodePrxCallbackPromise::PromiseforceDockerLoginPtr &ptr)
        {
            _promise_forceDockerLogin.setValue(ptr);
        }
        virtual void callback_forceDockerLogin_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:forceDockerLogin_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_forceDockerLogin.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromiseforceDockerLoginPtr > _promise_forceDockerLogin;

    public:
        struct PromisegetLogData: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string fileData;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetLogData > PromisegetLogDataPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisegetLogDataPtr > &promise)
        : _promise_getLogData(promise)
        {}
        
        virtual void callback_getLogData(const NodePrxCallbackPromise::PromisegetLogDataPtr &ptr)
        {
            _promise_getLogData.setValue(ptr);
        }
        virtual void callback_getLogData_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getLogData_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getLogData.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisegetLogDataPtr > _promise_getLogData;

    public:
        struct PromisegetLogFileList: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<std::string> logFileList;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetLogFileList > PromisegetLogFileListPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisegetLogFileListPtr > &promise)
        : _promise_getLogFileList(promise)
        {}
        
        virtual void callback_getLogFileList(const NodePrxCallbackPromise::PromisegetLogFileListPtr &ptr)
        {
            _promise_getLogFileList.setValue(ptr);
        }
        virtual void callback_getLogFileList_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getLogFileList_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getLogFileList.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisegetLogFileListPtr > _promise_getLogFileList;

    public:
        struct PromisegetNodeLoad: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string fileData;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetNodeLoad > PromisegetNodeLoadPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisegetNodeLoadPtr > &promise)
        : _promise_getNodeLoad(promise)
        {}
        
        virtual void callback_getNodeLoad(const NodePrxCallbackPromise::PromisegetNodeLoadPtr &ptr)
        {
            _promise_getNodeLoad.setValue(ptr);
        }
        virtual void callback_getNodeLoad_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getNodeLoad_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getNodeLoad.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisegetNodeLoadPtr > _promise_getNodeLoad;

    public:
        struct PromisegetPatchPercent: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::PatchInfo tPatchInfo;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetPatchPercent > PromisegetPatchPercentPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisegetPatchPercentPtr > &promise)
        : _promise_getPatchPercent(promise)
        {}
        
        virtual void callback_getPatchPercent(const NodePrxCallbackPromise::PromisegetPatchPercentPtr &ptr)
        {
            _promise_getPatchPercent.setValue(ptr);
        }
        virtual void callback_getPatchPercent_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getPatchPercent_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getPatchPercent.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisegetPatchPercentPtr > _promise_getPatchPercent;

    public:
        struct PromisegetStateInfo: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::ServerStateInfo info;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetStateInfo > PromisegetStateInfoPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisegetStateInfoPtr > &promise)
        : _promise_getStateInfo(promise)
        {}
        
        virtual void callback_getStateInfo(const NodePrxCallbackPromise::PromisegetStateInfoPtr &ptr)
        {
            _promise_getStateInfo.setValue(ptr);
        }
        virtual void callback_getStateInfo_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getStateInfo_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getStateInfo.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisegetStateInfoPtr > _promise_getStateInfo;

    public:
        struct PromiseloadServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromiseloadServer > PromiseloadServerPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromiseloadServerPtr > &promise)
        : _promise_loadServer(promise)
        {}
        
        virtual void callback_loadServer(const NodePrxCallbackPromise::PromiseloadServerPtr &ptr)
        {
            _promise_loadServer.setValue(ptr);
        }
        virtual void callback_loadServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:loadServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_loadServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromiseloadServerPtr > _promise_loadServer;

    public:
        struct PromisenotifyServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisenotifyServer > PromisenotifyServerPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisenotifyServerPtr > &promise)
        : _promise_notifyServer(promise)
        {}
        
        virtual void callback_notifyServer(const NodePrxCallbackPromise::PromisenotifyServerPtr &ptr)
        {
            _promise_notifyServer.setValue(ptr);
        }
        virtual void callback_notifyServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:notifyServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_notifyServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisenotifyServerPtr > _promise_notifyServer;

    public:
        struct PromisepatchPro: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisepatchPro > PromisepatchProPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisepatchProPtr > &promise)
        : _promise_patchPro(promise)
        {}
        
        virtual void callback_patchPro(const NodePrxCallbackPromise::PromisepatchProPtr &ptr)
        {
            _promise_patchPro.setValue(ptr);
        }
        virtual void callback_patchPro_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:patchPro_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_patchPro.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisepatchProPtr > _promise_patchPro;

    public:
        struct Promiseshutdown: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::Promiseshutdown > PromiseshutdownPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromiseshutdownPtr > &promise)
        : _promise_shutdown(promise)
        {}
        
        virtual void callback_shutdown(const NodePrxCallbackPromise::PromiseshutdownPtr &ptr)
        {
            _promise_shutdown.setValue(ptr);
        }
        virtual void callback_shutdown_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:shutdown_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_shutdown.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromiseshutdownPtr > _promise_shutdown;

    public:
        struct PromisestartServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisestartServer > PromisestartServerPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisestartServerPtr > &promise)
        : _promise_startServer(promise)
        {}
        
        virtual void callback_startServer(const NodePrxCallbackPromise::PromisestartServerPtr &ptr)
        {
            _promise_startServer.setValue(ptr);
        }
        virtual void callback_startServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:startServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_startServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisestartServerPtr > _promise_startServer;

    public:
        struct PromisestopAllServers: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisestopAllServers > PromisestopAllServersPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisestopAllServersPtr > &promise)
        : _promise_stopAllServers(promise)
        {}
        
        virtual void callback_stopAllServers(const NodePrxCallbackPromise::PromisestopAllServersPtr &ptr)
        {
            _promise_stopAllServers.setValue(ptr);
        }
        virtual void callback_stopAllServers_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:stopAllServers_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_stopAllServers.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisestopAllServersPtr > _promise_stopAllServers;

    public:
        struct PromisestopServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisestopServer > PromisestopServerPtr;

        NodePrxCallbackPromise(const tars::Promise< NodePrxCallbackPromise::PromisestopServerPtr > &promise)
        : _promise_stopServer(promise)
        {}
        
        virtual void callback_stopServer(const NodePrxCallbackPromise::PromisestopServerPtr &ptr)
        {
            _promise_stopServer.setValue(ptr);
        }
        virtual void callback_stopServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:stopServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_stopServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePrxCallbackPromise::PromisestopServerPtr > _promise_stopServer;

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __Node_all[]=
            {
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getPatchPercent",
                "getStateInfo",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer"
            };

            pair<string*, string*> r = equal_range(__Node_all, __Node_all+15, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisedelCachePtr ptr = new NodePrxCallbackPromise::PromisedelCache();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_delCache(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisedestroyServerPtr ptr = new NodePrxCallbackPromise::PromisedestroyServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_destroyServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromiseforceDockerLoginPtr ptr = new NodePrxCallbackPromise::PromiseforceDockerLogin();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_forceDockerLogin(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogData_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetLogDataPtr ptr = new NodePrxCallbackPromise::PromisegetLogData();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->fileData, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getLogData(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetLogFileListPtr ptr = new NodePrxCallbackPromise::PromisegetLogFileList();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->logFileList, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getLogFileList(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetNodeLoadPtr ptr = new NodePrxCallbackPromise::PromisegetNodeLoad();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->fileData, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getNodeLoad(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetPatchPercentPtr ptr = new NodePrxCallbackPromise::PromisegetPatchPercent();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->tPatchInfo, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getPatchPercent(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetStateInfoPtr ptr = new NodePrxCallbackPromise::PromisegetStateInfo();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->info, 3, true);
                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getStateInfo(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromiseloadServerPtr ptr = new NodePrxCallbackPromise::PromiseloadServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_loadServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisenotifyServerPtr ptr = new NodePrxCallbackPromise::PromisenotifyServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_notifyServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_patchPro_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisepatchProPtr ptr = new NodePrxCallbackPromise::PromisepatchPro();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_patchPro(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromiseshutdownPtr ptr = new NodePrxCallbackPromise::Promiseshutdown();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_shutdown(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisestartServerPtr ptr = new NodePrxCallbackPromise::PromisestartServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_startServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopAllServers_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisestopAllServersPtr ptr = new NodePrxCallbackPromise::PromisestopAllServers();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopAllServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopAllServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_stopAllServers(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePrxCallbackPromise::PromisestopServerPtr ptr = new NodePrxCallbackPromise::PromisestopServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_stopServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<NodePrxCallbackPromise> NodePrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class NodeCoroPrxCallback: public NodePrxCallback
    {
    public:
        virtual ~NodeCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __Node_all[]=
            {
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getPatchPercent",
                "getStateInfo",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer"
            };

            pair<string*, string*> r = equal_range(__Node_all, __Node_all+15, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_delCache(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_destroyServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<std::string> result;
                        _is.read(result, 1, true);
                        setResponseContext(_msg_->response->context);

                        callback_forceDockerLogin(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogData_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string fileData;
                        _is.read(fileData, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_getLogData(_ret, std::move(fileData));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<std::string> logFileList;
                        _is.read(logFileList, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_getLogFileList(_ret, std::move(logFileList));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string fileData;
                        _is.read(fileData, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_getNodeLoad(_ret, std::move(fileData));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::PatchInfo tPatchInfo;
                        _is.read(tPatchInfo, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_getPatchPercent(_ret, std::move(tPatchInfo));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::ServerStateInfo info;
                        _is.read(info, 3, true);
                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_getStateInfo(_ret, std::move(info), std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_loadServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_notifyServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_patchPro_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_patchPro(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(_msg_->response->context);

                        callback_shutdown(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_startServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopAllServers_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(_msg_->response->context);

                        callback_stopAllServers(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopAllServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopAllServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_stopServer(_ret, std::move(result));

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<NodeCoroPrxCallback> NodeCoroPrxCallbackPtr;

    /* proxy for client */
    class NodeProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Int32 delCache(const std::string & sFullCacheName,const std::string & sBackupPath,const std::string & sKey,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"delCache", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_delCache(NodePrxCallbackPtr callback,const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisedelCachePtr > promise_async_delCache(const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisedelCachePtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_delCache(NodeCoroPrxCallbackPtr callback,const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os, context, _mStatus, callback, true);
        }

        tars::Int32 destroyServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_destroyServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisedestroyServerPtr > promise_async_destroyServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisedestroyServerPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_destroyServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 forceDockerLogin(vector<std::string> &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_forceDockerLogin(NodePrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromiseforceDockerLoginPtr > promise_async_forceDockerLogin(const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromiseforceDockerLoginPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_forceDockerLogin(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getLogData(const std::string & application,const std::string & serverName,const std::string & logFile,const std::string & cmd,std::string &fileData,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(logFile, 3);
            _os.write(cmd, 4);
            _os.write(fileData, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getLogData", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(fileData, 5, true);
            return _ret;
        }

        void async_getLogData(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &logFile,const std::string &cmd,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(logFile, 3);
            _os.write(cmd, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogData", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisegetLogDataPtr > promise_async_getLogData(const std::string &application,const std::string &serverName,const std::string &logFile,const std::string &cmd,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisegetLogDataPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(logFile, 3);
            _os.write(cmd, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogData", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLogData(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &logFile,const std::string &cmd,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(logFile, 3);
            _os.write(cmd, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogData", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getLogFileList(const std::string & application,const std::string & serverName,vector<std::string> &logFileList,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(logFileList, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(logFileList, 3, true);
            return _ret;
        }

        void async_getLogFileList(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisegetLogFileListPtr > promise_async_getLogFileList(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisegetLogFileListPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLogFileList(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getNodeLoad(const std::string & application,const std::string & serverName,tars::Int32 pid,std::string &fileData,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(pid, 3);
            _os.write(fileData, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(fileData, 4, true);
            return _ret;
        }

        void async_getNodeLoad(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,tars::Int32 pid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(pid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisegetNodeLoadPtr > promise_async_getNodeLoad(const std::string &application,const std::string &serverName,tars::Int32 pid,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisegetNodeLoadPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(pid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getNodeLoad(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,tars::Int32 pid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(pid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getPatchPercent(const std::string & application,const std::string & serverName,tars::PatchInfo &tPatchInfo,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(tPatchInfo, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tPatchInfo, 3, true);
            return _ret;
        }

        void async_getPatchPercent(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisegetPatchPercentPtr > promise_async_getPatchPercent(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisegetPatchPercentPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getPatchPercent(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus, callback, true);
        }

        tars::Int32 getStateInfo(const std::string & application,const std::string & serverName,tars::ServerStateInfo &info,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(info, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getStateInfo", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(info, 3, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_getStateInfo(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getStateInfo", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisegetStateInfoPtr > promise_async_getStateInfo(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisegetStateInfoPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getStateInfo", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getStateInfo(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getStateInfo", _os, context, _mStatus, callback, true);
        }

        tars::Int32 loadServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"loadServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_loadServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromiseloadServerPtr > promise_async_loadServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromiseloadServerPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_loadServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & command,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_notifyServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisenotifyServerPtr > promise_async_notifyServer(const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisenotifyServerPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_notifyServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 patchPro(const tars::PatchRequest & req,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            _os.write(result, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"patchPro", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_patchPro(NodePrxCallbackPtr callback,const tars::PatchRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"patchPro", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisepatchProPtr > promise_async_patchPro(const tars::PatchRequest &req,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisepatchProPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"patchPro", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_patchPro(NodeCoroPrxCallbackPtr callback,const tars::PatchRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"patchPro", _os, context, _mStatus, callback, true);
        }

        tars::Int32 shutdown(std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"shutdown", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_shutdown(NodePrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromiseshutdownPtr > promise_async_shutdown(const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromiseshutdownPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_shutdown(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os, context, _mStatus, callback, true);
        }

        tars::Int32 startServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"startServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_startServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisestartServerPtr > promise_async_startServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisestartServerPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_startServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 stopAllServers(std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"stopAllServers", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_stopAllServers(NodePrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopAllServers", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisestopAllServersPtr > promise_async_stopAllServers(const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisestopAllServersPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopAllServers", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopAllServers(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopAllServers", _os, context, _mStatus, callback, true);
        }

        tars::Int32 stopServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"stopServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_stopServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePrxCallbackPromise::PromisestopServerPtr > promise_async_stopServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            tars::Promise< NodePrxCallbackPromise::PromisestopServerPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os, context, _mStatus, callback, true);
        }

        NodeProxy* tars_hash(uint32_t key)
        {
            return (NodeProxy*)ServantProxy::tars_hash(key);
        }

        NodeProxy* tars_consistent_hash(uint32_t key)
        {
            return (NodeProxy*)ServantProxy::tars_consistent_hash(key);
        }

        NodeProxy* tars_open_trace(bool traceParam = false)
        {
            return (NodeProxy*)ServantProxy::tars_open_trace(traceParam);
        }

        NodeProxy* tars_set_timeout(int msecond)
        {
            return (NodeProxy*)ServantProxy::tars_set_timeout(msecond);
        }

        static const char* tars_prxname() { return "NodeProxy"; }
    };
    typedef tars::TC_AutoPtr<NodeProxy> NodePrx;

    /* servant for server */
    class Node : public tars::Servant
    {
    public:
        virtual ~Node(){}
        virtual tars::Int32 delCache(const std::string & sFullCacheName,const std::string & sBackupPath,const std::string & sKey,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 delCache(std::string && sFullCacheName,std::string && sBackupPath,std::string && sKey,std::string &result,tars::TarsCurrentPtr _current_) 
        { return delCache(sFullCacheName, sBackupPath, sKey, result, _current_); }
        static void async_response_delCache(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_delCache(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"delCache", _os, _context);
            }
        }

        virtual tars::Int32 destroyServer(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 destroyServer(std::string && application,std::string && serverName,std::string &result,tars::TarsCurrentPtr _current_) 
        { return destroyServer(application, serverName, result, _current_); }
        static void async_response_destroyServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_destroyServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"destroyServer", _os, _context);
            }
        }

        virtual tars::Int32 forceDockerLogin(vector<std::string> &result,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_forceDockerLogin(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<std::string> &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_forceDockerLogin(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<std::string> &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"forceDockerLogin", _os, _context);
            }
        }

        virtual tars::Int32 getLogData(const std::string & application,const std::string & serverName,const std::string & logFile,const std::string & cmd,std::string &fileData,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getLogData(std::string && application,std::string && serverName,std::string && logFile,std::string && cmd,std::string &fileData,tars::TarsCurrentPtr _current_) 
        { return getLogData(application, serverName, logFile, cmd, fileData, _current_); }
        static void async_response_getLogData(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &fileData)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("fileData", fileData);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["fileData"] = tars::JsonOutput::writeJson(fileData);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getLogData(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &fileData, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getLogData", _os, _context);
            }
        }

        virtual tars::Int32 getLogFileList(const std::string & application,const std::string & serverName,vector<std::string> &logFileList,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getLogFileList(std::string && application,std::string && serverName,vector<std::string> &logFileList,tars::TarsCurrentPtr _current_) 
        { return getLogFileList(application, serverName, logFileList, _current_); }
        static void async_response_getLogFileList(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<std::string> &logFileList)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("logFileList", logFileList);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["logFileList"] = tars::JsonOutput::writeJson(logFileList);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(logFileList, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getLogFileList(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<std::string> &logFileList, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(logFileList, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getLogFileList", _os, _context);
            }
        }

        virtual tars::Int32 getNodeLoad(const std::string & application,const std::string & serverName,tars::Int32 pid,std::string &fileData,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getNodeLoad(std::string && application,std::string && serverName,tars::Int32 pid,std::string &fileData,tars::TarsCurrentPtr _current_) 
        { return getNodeLoad(application, serverName, pid, fileData, _current_); }
        static void async_response_getNodeLoad(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &fileData)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("fileData", fileData);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["fileData"] = tars::JsonOutput::writeJson(fileData);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getNodeLoad(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &fileData, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getNodeLoad", _os, _context);
            }
        }

        virtual tars::Int32 getPatchPercent(const std::string & application,const std::string & serverName,tars::PatchInfo &tPatchInfo,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getPatchPercent(std::string && application,std::string && serverName,tars::PatchInfo &tPatchInfo,tars::TarsCurrentPtr _current_) 
        { return getPatchPercent(application, serverName, tPatchInfo, _current_); }
        static void async_response_getPatchPercent(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const tars::PatchInfo &tPatchInfo)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("tPatchInfo", tPatchInfo);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tPatchInfo"] = tars::JsonOutput::writeJson(tPatchInfo);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tPatchInfo, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getPatchPercent(tars::CurrentPtr _current_, tars::Int32 _ret, const tars::PatchInfo &tPatchInfo, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tPatchInfo, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getPatchPercent", _os, _context);
            }
        }

        virtual tars::Int32 getStateInfo(const std::string & application,const std::string & serverName,tars::ServerStateInfo &info,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 getStateInfo(std::string && application,std::string && serverName,tars::ServerStateInfo &info,std::string &result,tars::TarsCurrentPtr _current_) 
        { return getStateInfo(application, serverName, info, result, _current_); }
        static void async_response_getStateInfo(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const tars::ServerStateInfo &info, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("info", info);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["info"] = tars::JsonOutput::writeJson(info);
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(info, 3);

                _os.write(result, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getStateInfo(tars::CurrentPtr _current_, tars::Int32 _ret, const tars::ServerStateInfo &info, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(info, 3);

                _os.write(result, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getStateInfo", _os, _context);
            }
        }

        virtual tars::Int32 loadServer(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 loadServer(std::string && application,std::string && serverName,std::string &result,tars::TarsCurrentPtr _current_) 
        { return loadServer(application, serverName, result, _current_); }
        static void async_response_loadServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_loadServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"loadServer", _os, _context);
            }
        }

        virtual tars::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & command,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 notifyServer(std::string && application,std::string && serverName,std::string && command,std::string &result,tars::TarsCurrentPtr _current_) 
        { return notifyServer(application, serverName, command, result, _current_); }
        static void async_response_notifyServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_notifyServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"notifyServer", _os, _context);
            }
        }

        virtual tars::Int32 patchPro(const tars::PatchRequest & req,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 patchPro(tars::PatchRequest && req,std::string &result,tars::TarsCurrentPtr _current_) 
        { return patchPro(req, result, _current_); }
        static void async_response_patchPro(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_patchPro(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"patchPro", _os, _context);
            }
        }

        virtual tars::Int32 shutdown(std::string &result,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_shutdown(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_shutdown(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"shutdown", _os, _context);
            }
        }

        virtual tars::Int32 startServer(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 startServer(std::string && application,std::string && serverName,std::string &result,tars::TarsCurrentPtr _current_) 
        { return startServer(application, serverName, result, _current_); }
        static void async_response_startServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_startServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"startServer", _os, _context);
            }
        }

        virtual tars::Int32 stopAllServers(std::string &result,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_stopAllServers(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_stopAllServers(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"stopAllServers", _os, _context);
            }
        }

        virtual tars::Int32 stopServer(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 stopServer(std::string && application,std::string && serverName,std::string &result,tars::TarsCurrentPtr _current_) 
        { return stopServer(application, serverName, result, _current_); }
        static void async_response_stopServer(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const std::string &result)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("result", result);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["result"] = tars::JsonOutput::writeJson(result);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_stopServer(tars::CurrentPtr _current_, tars::Int32 _ret, const std::string &result, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"stopServer", _os, _context);
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __tars__Node_all[]=
            {
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getPatchPercent",
                "getStateInfo",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer"
            };

            pair<string*, string*> r = equal_range(__tars__Node_all, __tars__Node_all+15, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __tars__Node_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sFullCacheName;
                    std::string sBackupPath;
                    std::string sKey;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sFullCacheName", sFullCacheName);
                        _tarsAttr_.get("sBackupPath", sBackupPath);
                        _tarsAttr_.get("sKey", sKey);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sFullCacheName, _jsonPtr->value["sFullCacheName"], true);
                        tars::JsonInput::readJson(sBackupPath, _jsonPtr->value["sBackupPath"], true);
                        tars::JsonInput::readJson(sKey, _jsonPtr->value["sKey"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(sFullCacheName, 1, true);
                        _is.read(sBackupPath, 2, true);
                        _is.read(sKey, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = delCache(std::move(sFullCacheName),std::move(sBackupPath),std::move(sKey),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = destroyServer(std::move(application),std::move(serverName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    vector<std::string> result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    tars::Int32 _ret = forceDockerLogin(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string logFile;
                    std::string cmd;
                    std::string fileData;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("logFile", logFile);
                        _tarsAttr_.get("cmd", cmd);
                        _tarsAttr_.getByDefault("fileData", fileData, fileData);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(logFile, _jsonPtr->value["logFile"], true);
                        tars::JsonInput::readJson(cmd, _jsonPtr->value["cmd"], true);
                        tars::JsonInput::readJson(fileData, _jsonPtr->value["fileData"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(logFile, 3, true);
                        _is.read(cmd, 4, true);
                        _is.read(fileData, 5, false);
                    }
                    tars::Int32 _ret = getLogData(std::move(application),std::move(serverName),std::move(logFile),std::move(cmd),fileData, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("fileData", fileData);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["fileData"] = tars::JsonOutput::writeJson(fileData);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(fileData, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    vector<std::string> logFileList;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.getByDefault("logFileList", logFileList, logFileList);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(logFileList, _jsonPtr->value["logFileList"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(logFileList, 3, false);
                    }
                    tars::Int32 _ret = getLogFileList(std::move(application),std::move(serverName),logFileList, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("logFileList", logFileList);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["logFileList"] = tars::JsonOutput::writeJson(logFileList);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(logFileList, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    tars::Int32 pid;
                    std::string fileData;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("pid", pid);
                        _tarsAttr_.getByDefault("fileData", fileData, fileData);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(pid, _jsonPtr->value["pid"], true);
                        tars::JsonInput::readJson(fileData, _jsonPtr->value["fileData"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(pid, 3, true);
                        _is.read(fileData, 4, false);
                    }
                    tars::Int32 _ret = getNodeLoad(std::move(application),std::move(serverName),pid,fileData, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("fileData", fileData);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["fileData"] = tars::JsonOutput::writeJson(fileData);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(fileData, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    tars::PatchInfo tPatchInfo;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.getByDefault("tPatchInfo", tPatchInfo, tPatchInfo);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(tPatchInfo, _jsonPtr->value["tPatchInfo"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(tPatchInfo, 3, false);
                    }
                    tars::Int32 _ret = getPatchPercent(std::move(application),std::move(serverName),tPatchInfo, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("tPatchInfo", tPatchInfo);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tPatchInfo"] = tars::JsonOutput::writeJson(tPatchInfo);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(tPatchInfo, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    tars::ServerStateInfo info;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.getByDefault("info", info, info);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(info, _jsonPtr->value["info"], false);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(info, 3, false);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = getStateInfo(std::move(application),std::move(serverName),info,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("info", info);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["info"] = tars::JsonOutput::writeJson(info);
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(info, 3);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = loadServer(std::move(application),std::move(serverName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string command;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.get("command", command);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(command, _jsonPtr->value["command"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(command, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = notifyServer(std::move(application),std::move(serverName),std::move(command),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::PatchRequest req;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("req", req);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(result, 2, false);
                    }
                    tars::Int32 _ret = patchPro(std::move(req),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    tars::Int32 _ret = shutdown(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = startServer(std::move(application),std::move(serverName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    tars::Int32 _ret = stopAllServers(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("application", application);
                        _tarsAttr_.get("serverName", serverName);
                        _tarsAttr_.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = stopServer(std::move(application),std::move(serverName),result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("result", result);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["result"] = tars::JsonOutput::writeJson(result);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
